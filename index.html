<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Secure MCQ Assessment</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { background: #f8f7f4; }
    .no-select { user-select: none; -webkit-user-select: none; }
    .option-btn { min-height: 48px; width: 100%; display: block; cursor: pointer; }
    .option-btn * { pointer-events: none; }
    .assessment-block::before {
      content: '';
      position: absolute;
      inset: 0;
      background-image:
        repeating-linear-gradient(
          var(--hatch-angle, 30deg),
          rgba(35, 35, 35, 0.14) 0px,
          rgba(35, 35, 35, 0.14) 1px,
          rgba(255, 255, 255, 0.0) 1px,
          rgba(255, 255, 255, 0.0) 11px
        ),
        repeating-linear-gradient(
          calc(var(--hatch-angle, 30deg) + 90deg),
          rgba(35, 35, 35, 0.10) 0px,
          rgba(35, 35, 35, 0.10) 1px,
          rgba(255, 255, 255, 0.0) 1px,
          rgba(255, 255, 255, 0.0) 11px
        );
      pointer-events: none;
      z-index: 4;
      border-radius: 0.75rem;
    }
    .ocr-grid-overlay {
      position: absolute;
      inset: 0;
      border-radius: 0.75rem;
      pointer-events: none;
      z-index: 35;
      background-image:
        linear-gradient(30deg, rgba(20, 20, 20, 0.16) 1px, transparent 1px),
        linear-gradient(120deg, rgba(20, 20, 20, 0.12) 1px, transparent 1px);
      background-size: 14px 14px, 14px 14px;
      mix-blend-mode: multiply;
    }
    @media print {
      #app { display: none !important; }
      #print-blocked { display: block !important; }
    }
  </style>
</head>
<body class="text-gray-900">
  <div id="print-blocked" class="hidden p-10 text-center text-2xl font-bold">This assessment cannot be printed.</div>
  <div id="app" class="min-h-screen"></div>

  <script>
    (() => {
      "use strict";

      const APP_TITLE = "Secure MCQ Assessment";
      const API_BASE = (() => {
        const sameOriginApi = `${location.origin}/api`;
        try {
          return localStorage.getItem("mcq_api_base") || sameOriginApi;
        } catch {
          return sameOriginApi;
        }
      })();
      const DEFAULT_CONFIG = {
        title: APP_TITLE,
        timeLimitMinutes: 60,
        drawCount: 10,
        questionsPerCategory: {},
        showPostReview: true,
        fullscreenEnforcement: true,
        tabSwitchWarnThreshold: 3,
        tabSwitchAutoSubmitThreshold: 5,
        allowRetakes: 0,
        passcode: ""
      };

      const INTEGRITY_NOTICE = `ASSESSMENT INTEGRITY NOTICE\n\nThis is a supervised assessment. The following measures are active:\n• Copy, paste, and text selection are disabled.\n• Switching browser tabs or windows will be logged.\n• This assessment cannot be printed or screenshotted for AI analysis.\n• Navigation backwards between questions is not permitted.\n• Questions and answer options are randomised for each student.\n• Your name and ID are embedded as a watermark in this assessment.\n• All violation events are recorded and may be reviewed by your invigilator.\n\nBy proceeding, you confirm that you are completing this assessment without unauthorised assistance, including AI tools, notes, or other persons.`;

      const questionBank = [
        { id: "q001", category: "General", difficulty: "easy", stem: "Which planet is closest to the Sun?", distractors: [{id:"a",text:"Venus",correct:false},{id:"b",text:"Mercury",correct:true},{id:"c",text:"Mars",correct:false},{id:"d",text:"Earth",correct:false}], explanation: "Mercury is the innermost planet in our solar system.", image: null },
        { id: "q002", category: "General", difficulty: "easy", stem: "What is the chemical symbol for water?", distractors: [{id:"a",text:"O2",correct:false},{id:"b",text:"CO2",correct:false},{id:"c",text:"H2O",correct:true},{id:"d",text:"NaCl",correct:false}], explanation: "Water consists of two hydrogen atoms bonded to one oxygen atom.", image: null },
        { id: "q003", category: "General", difficulty: "medium", stem: "Which of the following is NOT a programming language?", distractors: [{id:"a",text:"Python",correct:false},{id:"b",text:"Hadoop",correct:true},{id:"c",text:"Ruby",correct:false},{id:"d",text:"Swift",correct:false}], explanation: "Hadoop is a big-data framework, not a programming language.", image: null },
        { id: "q004", category: "General", difficulty: "medium", stem: "What does RAM stand for?", distractors: [{id:"a",text:"Read Access Memory",correct:false},{id:"b",text:"Random Access Memory",correct:true},{id:"c",text:"Rapid Application Module",correct:false},{id:"d",text:"Runtime Allocation Memory",correct:false}], explanation: "RAM stands for Random Access Memory, used for temporary data storage.", image: null },
        { id: "q005", category: "General", difficulty: "hard", stem: "In which year did the World Wide Web become publicly available?", distractors: [{id:"a",text:"1985",correct:false},{id:"b",text:"1999",correct:false},{id:"c",text:"1991",correct:true},{id:"d",text:"1995",correct:false}], explanation: "Tim Berners-Lee made the World Wide Web publicly available in 1991.", image: null },
        { id: "q006", category: "Science", difficulty: "easy", stem: "What is the powerhouse of the cell?", distractors: [{id:"a",text:"Nucleus",correct:false},{id:"b",text:"Ribosome",correct:false},{id:"c",text:"Mitochondria",correct:true},{id:"d",text:"Golgi apparatus",correct:false}], explanation: "Mitochondria produce ATP, the cell's primary energy currency.", image: null },
        { id: "q007", category: "Science", difficulty: "medium", stem: "What is the speed of light in a vacuum (approximate)?", distractors: [{id:"a",text:"300,000 km/s",correct:true},{id:"b",text:"150,000 km/s",correct:false},{id:"c",text:"1,080,000 km/h",correct:false},{id:"d",text:"30,000 km/s",correct:false}], explanation: "Light travels at approximately 299,792 km/s in a vacuum.", image: null },
        { id: "q008", category: "Mathematics", difficulty: "easy", stem: "What is the value of π (pi) to two decimal places?", distractors: [{id:"a",text:"3.12",correct:false},{id:"b",text:"3.41",correct:false},{id:"c",text:"3.14",correct:true},{id:"d",text:"3.16",correct:false}], explanation: "Pi is approximately 3.14159, which rounds to 3.14.", image: null },
        { id: "q009", category: "Mathematics", difficulty: "medium", stem: "What is the square root of 144?", distractors: [{id:"a",text:"11",correct:false},{id:"b",text:"14",correct:false},{id:"c",text:"12",correct:true},{id:"d",text:"13",correct:false}], explanation: "12 × 12 = 144, so the square root of 144 is 12.", image: null },
        { id: "q010", category: "History", difficulty: "medium", stem: "In which year did the First World War begin?", distractors: [{id:"a",text:"1916",correct:false},{id:"b",text:"1914",correct:true},{id:"c",text:"1918",correct:false},{id:"d",text:"1912",correct:false}], explanation: "World War I began in 1914 following the assassination of Archduke Franz Ferdinand.", image: null }
      ];

      const DEFAULT_ADMIN_DRAFT = {
        bankCode: "",
        bankName: "",
        uploadMode: "append",
        testName: "",
        testCode: "",
        totalQuestions: 10,
        durationMinutes: 60,
        windowStart: "",
        windowEnd: "",
        status: "draft",
        resultsReleased: false,
        passcode: "",
        allocations: [{ bankCode: "", count: 1 }]
      };

      function normalizeAdminDraft(raw) {
        const src = raw && typeof raw === "object" ? raw : {};
        const base = {
          ...DEFAULT_ADMIN_DRAFT,
          ...src
        };
        const allocations = Array.isArray(base.allocations) && base.allocations.length
          ? base.allocations
          : [{ bankCode: "", count: 1 }];
        return {
          bankCode: String(base.bankCode || ""),
          bankName: String(base.bankName || ""),
          uploadMode: base.uploadMode === "replace" ? "replace" : "append",
          testName: String(base.testName || ""),
          testCode: String(base.testCode || ""),
          totalQuestions: Math.max(1, Number(base.totalQuestions || 10)),
          durationMinutes: Math.max(1, Number(base.durationMinutes || 60)),
          windowStart: toLocalDateTimeInputValue(base.windowStart || ""),
          windowEnd: toLocalDateTimeInputValue(base.windowEnd || ""),
          status: ["draft", "active", "closed"].includes(String(base.status || "draft")) ? String(base.status) : "draft",
          resultsReleased: !!base.resultsReleased,
          passcode: String(base.passcode || ""),
          allocations: allocations.map((a) => ({
            bankCode: String(a.bankCode || ""),
            count: Math.max(1, Number(a.count || 1))
          }))
        };
      }

      function parseRouteFromHash() {
        const hash = location.hash || "#/login";
        if (hash.startsWith("#/admin")) return { route: "admin", resultAccessToken: "" };
        if (hash.startsWith("#/released-results")) {
          const query = hash.includes("?") ? hash.slice(hash.indexOf("?") + 1) : "";
          const params = new URLSearchParams(query);
          return {
            route: "released-results",
            resultAccessToken: String(params.get("access") || "").trim()
          };
        }
        return { route: "login", resultAccessToken: "" };
      }

      const initialHashRoute = parseRouteFromHash();
      const state = {
        route: initialHashRoute.route,
        publicResultAccessToken: initialHashRoute.resultAccessToken,
        publicResult: { loading: false, error: "", payload: null },
        config: loadJSON("mcq_config", DEFAULT_CONFIG),
        bank: loadJSON("mcq_bank", questionBank),
        results: loadJSON("mcq_results", []),
        attempts: loadJSON("mcq_attempts", {}),
        exitedIds: loadJSON("mcq_exited_ids", []),
        adminAuthed: false,
        adminToken: "",
        adminData: {
          banks: [],
          tests: [],
          results: [],
          analytics: [],
          uploadSummary: null
        },
        adminDraft: normalizeAdminDraft(loadJSON("mcq_admin_draft", DEFAULT_ADMIN_DRAFT)),
        session: null,
        violations: [],
        selectedOptionId: null,
        currentQuestionIndex: 0,
        answers: [],
        timer: { remainingMs: 0, windowRemainingMs: 0, startMs: 0, endMs: 0, windowEndMs: 0 },
        ui: { overlay: null, inactivityOverlay: false, submitted: false, submitting: false, advancing: false, zoomWarning: false }
      };
      state.activeAssessment = null;
      state.currentQuestionPayload = null;
      state.currentResult = null;
      state.eventGuardUntilMs = 0;

      const app = document.getElementById("app");
      if (app) {
        app.innerHTML = `<div class="max-w-2xl mx-auto p-6 mt-8 bg-white rounded-xl shadow">
          <h1 class="text-xl font-semibold">Loading Secure MCQ App...</h1>
          <p class="text-sm text-gray-600 mt-2">If this message remains, a startup error occurred.</p>
        </div>`;
      }

      function showStartupError(msg) {
        if (!app) return;
        app.innerHTML = `<div class="max-w-3xl mx-auto p-6 mt-8 bg-red-50 border border-red-300 rounded-xl">
          <h1 class="text-xl font-bold text-red-800">Application Startup Error</h1>
          <pre class="mt-3 text-xs text-red-900 whitespace-pre-wrap">${escapeHtml(String(msg || "Unknown startup error"))}</pre>
          <p class="mt-3 text-sm text-red-700">Please share this message with support.</p>
        </div>`;
      }

      window.addEventListener("error", (e) => {
        showStartupError(e.error?.stack || e.message || "window error");
      });
      window.addEventListener("unhandledrejection", (e) => {
        showStartupError(e.reason?.stack || e.reason?.message || String(e.reason || "promise rejection"));
      });
      let tickTimerId = null;
      let noiseTimerId = null;
      let watermarkTimerId = null;
      let devtoolsTimerId = null;
      let inactivityTimerId = null;
      let lastActivityAt = Date.now();
      let blurCounted = false;
      let devtoolsConsecutiveHits = 0;
      let lastDevtoolsAlertAt = 0;
      let disconnectNotified = false;

      window.addEventListener("hashchange", () => {
        const parsed = parseRouteFromHash();
        state.route = parsed.route;
        state.publicResultAccessToken = parsed.resultAccessToken;
        if (parsed.route === "released-results") {
          state.publicResult = { loading: false, error: "", payload: null };
        }
        render();
      });

      function loadJSON(key, fallback) {
        try {
          const raw = localStorage.getItem(key);
          return raw ? JSON.parse(raw) : fallback;
        } catch {
          return fallback;
        }
      }

      function saveJSON(key, value) {
        localStorage.setItem(key, JSON.stringify(value));
      }

      async function apiFetch(path, options = {}) {
        const res = await fetch(`${API_BASE}${path}`, {
          method: options.method || "GET",
          headers: { "Content-Type": "application/json", ...(options.headers || {}) },
          body: options.body ? JSON.stringify(options.body) : undefined
        });
        const data = await res.json().catch(() => ({}));
        if (!res.ok) {
          const err = new Error(data.error || data.message || `api_error_${res.status}`);
          err.code = data.error || data.code || `http_${res.status}`;
          err.payload = data;
          throw err;
        }
        return data;
      }

      async function sessionApiFetch(path, options = {}) {
        if (!state.session?.authToken) {
          throw new Error("missing_session_auth_token");
        }
        return apiFetch(path, {
          ...options,
          headers: {
            ...(options.headers || {}),
            Authorization: `Bearer ${state.session.authToken}`
          }
        });
      }

      async function adminApiFetch(path, options = {}) {
        if (!state.adminToken) throw new Error("admin_not_authenticated");
        return apiFetch(path, {
          ...options,
          headers: {
            ...(options.headers || {}),
            Authorization: `Bearer ${state.adminToken}`
          }
        });
      }

      async function fetchPublicReleasedResult(accessToken) {
        if (!accessToken) {
          state.publicResult = { loading: false, error: "Missing result access token.", payload: null };
          render();
          return;
        }
        state.publicResult = { loading: true, error: "", payload: null };
        render();
        try {
          const payload = await apiFetch(`/results/${encodeURIComponent(accessToken)}`);
          state.publicResult = { loading: false, error: "", payload };
        } catch (err) {
          const msg = err.code === "results_not_released"
            ? "Results are not released yet. Please check again later."
            : `Unable to load result: ${humanizeError(err)}`;
          state.publicResult = { loading: false, error: msg, payload: null };
        }
        render();
      }

      async function loadActiveAssessment() {
        try {
          const active = await apiFetch("/assessment/active");
          if (!active) return;
          state.activeAssessment = active;
          state.config.title = active.title || state.config.title;
          state.config.timeLimitMinutes = Math.max(1, Math.round((Number(active.duration_seconds || 3600)) / 60));
          state.config.drawCount = Number(active.draw_count || state.config.drawCount);
          state.config.showPostReview = !!active.show_post_review;
          state.config.fullscreenEnforcement = !!active.fullscreen_enforcement;
          state.config.tabSwitchWarnThreshold = Number(active.tab_warn_threshold || state.config.tabSwitchWarnThreshold);
          state.config.tabSwitchAutoSubmitThreshold = Number(active.tab_autosubmit_threshold || state.config.tabSwitchAutoSubmitThreshold);
          state.config.allowRetakes = Number(active.allow_retakes || state.config.allowRetakes);
        } catch {
          // Keep local defaults when API metadata fetch fails.
        }
      }

      function escapeHtml(s) {
        return String(s).replace(/[&<>"']/g, (c) => ({"&":"&amp;","<":"&lt;",">":"&gt;","\"":"&quot;","'":"&#39;"})[c]);
      }

      function sanitizeInput(v) {
        return String(v || "").replace(/[<>`]/g, "").trim();
      }

      function humanizeError(err) {
        if (err?.payload?.error) return String(err.payload.error);
        if (err?.payload?.message) return String(err.payload.message);
        if (err?.message) return String(err.message);
        return "unknown_error";
      }

      function persistAdminDraft() {
        saveJSON("mcq_admin_draft", state.adminDraft);
      }

      function randomSuffix(len = 2) {
        const chars = "ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz23456789";
        let out = "";
        for (let i = 0; i < len; i += 1) {
          out += chars[Math.floor(Math.random() * chars.length)];
        }
        return out;
      }

      function deriveAdminFieldsFromBankCode(value) {
        const raw = sanitizeInput(value || "");
        const tokens = raw.split(/\s+/).filter(Boolean);
        const firstWord = tokens[0] || "";
        const numberMatch = raw.match(/\d+/g);
        const trailingNumber = numberMatch ? numberMatch[numberMatch.length - 1] : "";

        if (!firstWord) {
          return { bankCode: "", bankName: "", testName: "", testCode: "", passcode: "" };
        }

        const firstWordTitle = firstWord.charAt(0).toUpperCase() + firstWord.slice(1).toLowerCase();
        const cy = firstWordTitle.slice(0, 2) || firstWordTitle.slice(0, 1);
        const c = firstWordTitle.slice(0, 1);
        const numberPart = trailingNumber || "";
        const bankName = `${firstWordTitle}${numberPart}`;
        const testName = `${c}Test${numberPart}`;
        const testCode = `${cy}test${numberPart}`;
        const passcode = `${cy}TeSt${numberPart}${randomSuffix(2)}`;

        return {
          bankCode: raw,
          bankName,
          testName,
          testCode,
          passcode
        };
      }

      function localDateTimeInputToIso(value) {
        const raw = String(value || "").trim();
        if (!raw) return "";
        const d = new Date(raw);
        if (Number.isNaN(d.getTime())) return "";
        return d.toISOString();
      }

      function toLocalDateTimeInputValue(value) {
        const raw = String(value || "").trim();
        if (!raw) return "";
        const d = new Date(raw);
        if (Number.isNaN(d.getTime())) return "";
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        const hh = String(d.getHours()).padStart(2, "0");
        const mi = String(d.getMinutes()).padStart(2, "0");
        return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
      }


      function uuid() {
        return crypto.randomUUID ? crypto.randomUUID() : "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, c => {
          const r = Math.random() * 16 | 0, s = c === "x" ? r : (r & 0x3 | 0x8);
          return s.toString(16);
        });
      }

      function fisherYates(arr) {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      }

      function drawQuestions(bank, cfg) {
        if (cfg.questionsPerCategory && Object.keys(cfg.questionsPerCategory).length) {
          const out = [];
          const taken = new Set();
          for (const [cat, n] of Object.entries(cfg.questionsPerCategory)) {
            const pool = fisherYates(bank.filter(q => q.category === cat));
            for (let i = 0; i < Math.min(Number(n) || 0, pool.length); i++) {
              out.push(pool[i]);
              taken.add(pool[i].id);
            }
          }
          if (out.length < cfg.drawCount) {
            const extra = fisherYates(bank.filter(q => !taken.has(q.id))).slice(0, cfg.drawCount - out.length);
            out.push(...extra);
          }
          return fisherYates(out).slice(0, cfg.drawCount);
        }
        return fisherYates(bank).slice(0, Math.min(cfg.drawCount, bank.length));
      }

      function createSession(identity) {
        const startMs = Date.now();
        const token = uuid();
        const seed = uuid();
        const chosen = drawQuestions(state.bank, state.config);
        const questions = chosen.map((q) => {
          const shuffledDistractors = fisherYates(q.distractors);
          return {
            id: q.id,
            category: q.category,
            difficulty: q.difficulty,
            stem: q.stem,
            explanation: q.explanation,
            image: q.image || null,
            distractors: shuffledDistractors.map((d, idx) => ({
              displayLabel: String.fromCharCode(65 + idx),
              originalId: d.id,
              text: d.text,
              correct: !!d.correct
            }))
          };
        });

        return {
          token,
          seed,
          identity,
          startedAt: startMs,
          userAgent: navigator.userAgent,
          screen: `${screen.width}x${screen.height}`,
          questionOrder: questions.map(q => q.id),
          questions
        };
      }

      function logViolation(type, details) {
        if (!state.session) return;
        state.violations.push({
          token: state.session.token,
          type,
          details: details || "",
          at: new Date().toISOString(),
          index: state.currentQuestionIndex + 1
        });
        sessionApiFetch(`/session/${state.session.token}/event`, {
          method: "POST",
          body: {
            eventType: type,
            details: details || "",
            questionIndex: state.currentQuestionIndex
          }
        }).catch(() => {});
        render();
      }

      function activateHardeners() {
        // Block clipboard operations during assessment.
        ["copy", "cut", "paste", "contextmenu", "dragstart"].forEach((evt) => {
          document.addEventListener(evt, blockEvent, true);
        });

        // Block common keyboard shortcuts for saving/printing/devtools/source/clipboard.
        document.addEventListener("keydown", onSecureKeydown, true);

        // Block browser back by repushing history state.
        history.pushState(null, "", location.href);
        window.addEventListener("popstate", onPopState);

        // Log tab visibility changes and escalate.
        document.addEventListener("visibilitychange", onVisibilityChange);

        // Log window blur (app switching) once per blur episode.
        window.addEventListener("blur", onBlur);
        window.addEventListener("focus", onFocus);

        // Best-effort print block: intercept beforeprint and flag violation.
        window.addEventListener("beforeprint", onBeforePrint);

        // Fullscreen exit detection (warning + logging).
        document.addEventListener("fullscreenchange", onFullscreenChange);

        // Best-effort disconnect tracking for reconnect policy.
        window.addEventListener("pagehide", onPageHide);
        window.addEventListener("beforeunload", onPageHide);

        // Best-effort devtools detection as deterrent only (can be bypassed).
        devtoolsTimerId = setInterval(checkDevtools, 1000);

        // Inactivity detection: overlay after 60s idle.
        ["mousemove", "keydown", "click", "touchstart"].forEach((evt) => {
          document.addEventListener(evt, onActivity, true);
        });
        resetInactivity();
      }

      function deactivateHardeners() {
        ["copy", "cut", "paste", "contextmenu", "dragstart"].forEach((evt) => document.removeEventListener(evt, blockEvent, true));
        document.removeEventListener("keydown", onSecureKeydown, true);
        window.removeEventListener("popstate", onPopState);
        document.removeEventListener("visibilitychange", onVisibilityChange);
        window.removeEventListener("blur", onBlur);
        window.removeEventListener("focus", onFocus);
        window.removeEventListener("beforeprint", onBeforePrint);
        document.removeEventListener("fullscreenchange", onFullscreenChange);
        window.removeEventListener("pagehide", onPageHide);
        window.removeEventListener("beforeunload", onPageHide);
        if (devtoolsTimerId) clearInterval(devtoolsTimerId);
        ["mousemove", "keydown", "click", "touchstart"].forEach((evt) => document.removeEventListener(evt, onActivity, true));
        if (inactivityTimerId) clearTimeout(inactivityTimerId);
      }

      function blockEvent(e) { e.preventDefault(); }

      function onSecureKeydown(e) {
        const k = (e.key || "").toLowerCase();
        const ctrl = e.ctrlKey || e.metaKey;
        const shift = e.shiftKey;
        const blocked =
          (ctrl && ["c", "x", "v", "a", "s", "p", "u"].includes(k)) ||
          k === "f12" ||
          (ctrl && shift && ["i", "j"].includes(k));

        if (blocked) {
          e.preventDefault();
          logViolation("blocked_shortcut", `${e.key} ctrl=${ctrl} shift=${shift}`);
          state.ui.overlay = "Blocked action detected. This event was logged.";
          render();
        }
      }

      function onPopState() {
        history.pushState(null, "", location.href);
        logViolation("back_navigation_attempt", "popstate intercepted");
      }

      function onVisibilityChange() {
        if (Date.now() < state.eventGuardUntilMs) return;
        if (document.hidden) {
          logViolation("tab_switch", "document hidden");
          enforceViolationEscalation();
        }
      }

      function onBlur() {
        if (Date.now() < state.eventGuardUntilMs) return;
        if (!blurCounted) {
          blurCounted = true;
          logViolation("window_blur", "window lost focus");
          enforceViolationEscalation();
        }
      }

      function onFocus() { blurCounted = false; }

      function onBeforePrint(e) {
        e.preventDefault();
        logViolation("print_attempt", "beforeprint intercepted");
        alert("Printing during assessment is blocked.");
      }

      function onFullscreenChange() {
        if (Date.now() < state.eventGuardUntilMs) return;
        if (state.session && !document.fullscreenElement) {
          logViolation("fullscreen_exit", "user exited fullscreen");
          state.ui.overlay = "Fullscreen was exited. This has been recorded.";
          render();
        }
      }

      function onPageHide() {
        notifyDisconnect();
      }

      function notifyDisconnect() {
        if (!state.session || disconnectNotified || state.ui.submitted) return;
        disconnectNotified = true;
        fetch(`${API_BASE}/session/${state.session.token}/disconnect`, {
          method: "POST",
          keepalive: true,
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${state.session.authToken || ""}`
          },
          body: JSON.stringify({ reason: "page_unload" })
        }).catch(() => {});
      }

      function checkDevtools() {
        const wGap = window.outerWidth - window.innerWidth;
        const hGap = window.outerHeight - window.innerHeight;
        const now = Date.now();
        // Best-effort heuristic only: require repeated suspicious readings and apply cooldown
        // to reduce false positives on uncommon monitors/browser UI layouts.
        const suspicious = (wGap > 280 || hGap > 220);
        if (suspicious) {
          devtoolsConsecutiveHits += 1;
        } else {
          devtoolsConsecutiveHits = 0;
        }

        const cooldownMs = 90000;
        if (devtoolsConsecutiveHits >= 3 && (now - lastDevtoolsAlertAt) > cooldownMs) {
          lastDevtoolsAlertAt = now;
          logViolation("devtools_suspected", `gap:${wGap}x${hGap}`);
          state.ui.overlay = "Developer tools suspected. This event has been logged.";
          render();
        }
      }

      function onActivity() {
        lastActivityAt = Date.now();
        if (state.ui.inactivityOverlay) {
          state.ui.inactivityOverlay = false;
          render();
        }
        resetInactivity();
      }

      function resetInactivity() {
        if (inactivityTimerId) clearTimeout(inactivityTimerId);
        inactivityTimerId = setTimeout(() => {
          if (!state.session || state.ui.submitted) return;
          const idle = Date.now() - lastActivityAt;
          if (idle >= 60000) {
            state.ui.inactivityOverlay = true;
            logViolation("inactivity", `idle_ms:${idle}`);
            render();
          }
        }, 61000);
      }

      function enforceViolationEscalation() {
        const tabLikeCount = state.violations.filter(v => ["tab_switch", "window_blur"].includes(v.type)).length;
        if (tabLikeCount >= state.config.tabSwitchAutoSubmitThreshold) {
          state.ui.overlay = "Violation threshold reached. Auto-submitting assessment.";
          render();
          submitAssessment(true);
          return;
        }
        if (tabLikeCount >= state.config.tabSwitchWarnThreshold) {
          state.ui.overlay = `Warning: ${tabLikeCount} focus/tab violations recorded.`;
          render();
        }
      }

      function startTimer(expiresAtIso) {
        const now = Date.now();
        state.timer.startMs = now;
        state.timer.endMs = expiresAtIso ? new Date(expiresAtIso).getTime() : now + state.config.timeLimitMinutes * 60 * 1000;
        state.timer.remainingMs = state.timer.endMs - now;
        state.timer.windowRemainingMs = state.timer.windowEndMs ? Math.max(0, state.timer.windowEndMs - now) : state.timer.remainingMs;

        tickTimerId = setInterval(() => {
          if (!state.session || state.ui.submitted) return;
          const nowTick = Date.now();
          const remaining = Math.max(0, state.timer.endMs - nowTick);
          state.timer.remainingMs = remaining;
          state.timer.windowRemainingMs = state.timer.windowEndMs ? Math.max(0, state.timer.windowEndMs - nowTick) : remaining;
          state.ui.zoomWarning = Math.abs((window.devicePixelRatio || 1) - 1) > 0.15;
          if (remaining === 0) {
            logViolation("timer_expired", "auto submit");
            submitAssessment(true);
            return;
          }
          render();
        }, 500);
      }

      function stopTimer() {
        if (tickTimerId) clearInterval(tickTimerId);
        tickTimerId = null;
      }

      function requestFullscreenIfEnabled() {
        if (!state.config.fullscreenEnforcement) return;
        const el = document.documentElement;
        if (el.requestFullscreen) el.requestFullscreen().catch(() => {
          logViolation("fullscreen_request_failed", "browser denied fullscreen");
        });
      }

      async function startAssessment(identity) {
        const id = sanitizeInput(identity.studentId);
        if ((state.exitedIds || []).includes(id)) {
          alert("This student ID is locked and cannot attempt this assessment again.");
          return;
        }
        const prior = Number(state.attempts[id] || 0);
        if (prior >= Number(state.config.allowRetakes) + 1) {
          alert("Attempt limit reached for this ID.");
          return;
        }

        try {
          const start = await apiFetch("/auth/start", {
            method: "POST",
            body: {
              fullName: sanitizeInput(identity.fullName),
              studentId: id,
              email: sanitizeInput(identity.email || ""),
              assessmentCode: sanitizeInput(identity.assessmentCode || state.activeAssessment?.code || state.config.assessmentCode || ""),
              passcode: sanitizeInput(identity.passcode || ""),
              screenResolution: `${screen.width}x${screen.height}`
            }
          });

          if (start.error === "session_terminated_after_second_disconnect") {
            alert("This session was terminated after a second disconnect.");
            return;
          }

          state.session = {
            token: start.token,
            seed: start.seed,
            authToken: start.sessionAuthToken,
            identity: {
              fullName: sanitizeInput(identity.fullName),
              studentId: id,
              email: sanitizeInput(identity.email || "")
            },
            startedAt: new Date(start.startedAt).getTime(),
            resumed: !!start.resumed
          };

          state.config.title = start.assessment?.title || state.config.title;
          state.config.drawCount = Number(start.assessment?.drawCount || state.config.drawCount);
          state.config.timeLimitMinutes = Math.max(1, Math.round((Number(start.assessment?.durationSeconds || 3600)) / 60));
          state.config.showPostReview = !!start.assessment?.showPostReview;
          state.config.fullscreenEnforcement = !!start.assessment?.fullscreenEnforcement;
          state.config.tabSwitchWarnThreshold = Number(start.assessment?.tabWarnThreshold || state.config.tabSwitchWarnThreshold);
          state.config.tabSwitchAutoSubmitThreshold = Number(start.assessment?.tabAutosubmitThreshold || state.config.tabSwitchAutoSubmitThreshold);
          state.config.allowRetakes = Number(start.assessment?.allowRetakes || state.config.allowRetakes);
          state.timer.windowEndMs = start.assessment?.windowEnd ? new Date(start.assessment.windowEnd).getTime() : 0;

          state.violations = [];
          state.answers = [];
          state.currentQuestionIndex = 0;
          state.selectedOptionId = null;
          state.currentQuestionPayload = null;
          state.ui.overlay = null;
          state.ui.inactivityOverlay = false;
          state.ui.submitted = false;
          state.ui.submitting = false;
          state.ui.advancing = false;
          state.eventGuardUntilMs = Date.now() + 8000;
          disconnectNotified = false;
          lastActivityAt = Date.now();

          const first = await sessionApiFetch(`/session/${start.token}/question`);
          state.currentQuestionPayload = first;
          state.currentQuestionIndex = Number(first.questionIndex || 0);
          state.timer.windowRemainingMs = Number(first.windowRemainingMs || 0);
          if (start.reconnectWarning) {
            alert(start.reconnectWarning);
          }

          activateHardeners();
          startTimer(start.expiresAt);
          state.route = "assessment";
          render();
        } catch (err) {
          if (err.code === "assessment_not_open") {
            const mins = Math.max(1, Math.ceil(Number(err.payload?.opensInMs || 0) / 60000));
            alert(`Assessment is not open yet. Opens in about ${mins} minute(s).`);
            return;
          }
          if (err.code === "assessment_closed") {
            alert("Assessment window has closed.");
            return;
          }
          if (err.code === "session_terminated_after_second_disconnect") {
            alert("Session terminated after second disconnect and auto-submitted.");
            state.currentResult = err.payload?.result || null;
            state.route = "results";
            render();
            return;
          }
          alert(`Unable to start assessment: ${err.message}`);
        }
      }

      function currentQuestion() {
        if (!state.currentQuestionPayload) return null;
        return state.currentQuestionPayload.question || null;
      }

      async function nextQuestion() {
        if (state.ui.advancing) return;
        if (state.selectedOptionId == null) return;
        const q = currentQuestion();
        if (!q) return;
        try {
          const selected = state.selectedOptionId;
          state.ui.advancing = true;
          render();
          const response = await sessionApiFetch(`/session/${state.session.token}/answer`, {
            method: "POST",
            body: {
              questionId: q.id,
              selectedOriginalId: selected
            }
          });

          if (response.done) {
            applySubmissionResponse(response.submission || response);
            state.results = [state.currentResult].concat(state.results);
            saveJSON("mcq_results", state.results);
            const sid = state.session.identity.studentId;
            state.attempts[sid] = Number(state.attempts[sid] || 0) + 1;
            saveJSON("mcq_attempts", state.attempts);
            state.ui.submitted = true;
            state.ui.submitting = false;
            state.ui.advancing = false;
            stopTimer();
            deactivateHardeners();
            state.route = "results";
            render();
            return;
          }

          state.currentQuestionPayload = response.next;
          state.currentQuestionIndex = Number(response.next?.questionIndex || state.currentQuestionIndex + 1);
          if (Number.isFinite(Number(response.remainingMs))) {
            state.timer.remainingMs = Math.max(0, Number(response.remainingMs));
          }
          if (Number.isFinite(Number(response.windowRemainingMs))) {
            state.timer.windowRemainingMs = Math.max(0, Number(response.windowRemainingMs));
          }
          state.selectedOptionId = null;
          state.ui.advancing = false;
          rerollHatchAngle();
          render();
        } catch (err) {
          state.ui.advancing = false;
          alert(`Unable to submit answer: ${err.message}`);
          render();
        }
      }

      async function submitAssessment(auto) {
        if (!state.session || state.ui.submitted || state.ui.submitting) return;
        state.ui.submitting = true;
        render();
        try {
          const response = await sessionApiFetch(`/session/${state.session.token}/submit`, {
            method: "POST",
            body: { autoSubmitted: !!auto }
          });
          applySubmissionResponse(response);
          state.results = [state.currentResult].concat(state.results);
          saveJSON("mcq_results", state.results);

          const sid = state.session.identity.studentId;
          state.attempts[sid] = Number(state.attempts[sid] || 0) + 1;
          saveJSON("mcq_attempts", state.attempts);

          state.ui.submitting = false;
          state.ui.submitted = true;
          state.ui.advancing = false;
          stopTimer();
          deactivateHardeners();
          state.route = "results";
          render();
        } catch (err) {
          state.ui.submitting = false;
          state.ui.advancing = false;
          alert(`Unable to submit assessment: ${err.message}`);
          render();
        }
      }

      function applySubmissionResponse(response) {
        if (response.resultsReleased && response.result) {
          state.currentResult = {
            ...response.result,
            violations: state.violations.slice(),
            violationCount: state.violations.length
          };
          return;
        }
        state.currentResult = {
          token: response.token || state.session?.token,
          submittedAt: response.submittedAt || new Date().toISOString(),
          score: null,
          total: state.config.drawCount,
          percentage: null,
          timeTakenMs: Date.now() - (state.session?.startedAt || Date.now()),
          violationCount: state.violations.length,
          resultsReleased: false,
          pendingMessage: response.message || "Results are pending admin release.",
          student: state.session?.identity || { fullName: "", studentId: "" },
          details: [],
          violations: state.violations.slice()
        };
      }

      function clearVisualTimers() {
        if (noiseTimerId) clearInterval(noiseTimerId);
        if (watermarkTimerId) clearInterval(watermarkTimerId);
      }

      function rerollHatchAngle() {
        const host = document.querySelector(".assessment-block");
        if (!host) return;
        const angle = 15 + Math.floor(Math.random() * 31);
        host.style.setProperty("--hatch-angle", `${angle}deg`);
      }

      function startNoiseAndWatermark() {
        const noiseCanvas = document.getElementById("noiseCanvas");
        const wmCanvas = document.getElementById("wmCanvas");
        const card = document.getElementById("questionCard");
        if (!noiseCanvas || !wmCanvas || !card || !state.session) return;

        function sizeCanvas(canvas) {
          const rect = card.getBoundingClientRect();
          canvas.width = Math.floor(rect.width);
          canvas.height = Math.floor(rect.height);
        }
        sizeCanvas(noiseCanvas);
        sizeCanvas(wmCanvas);

        function drawNoise() {
          const ctx = noiseCanvas.getContext("2d");
          const w = noiseCanvas.width;
          const h = noiseCanvas.height;
          ctx.clearRect(0, 0, w, h);
          // Random greyscale micro-dot noise (~18% opacity), refreshed >=2fps.
          for (let y = 0; y < h; y += 2) {
            for (let x = 0; x < w; x += 2) {
              if (Math.random() < 0.52) {
                const g = Math.floor(Math.random() * 90) + 80;
                ctx.fillStyle = `rgba(${g},${g},${g},0.22)`;
                ctx.fillRect(x, y, 1, 1);
              }
            }
          }
        }

        function drawWatermark() {
          const ctx = wmCanvas.getContext("2d");
          const w = wmCanvas.width;
          const h = wmCanvas.height;
          ctx.clearRect(0, 0, w, h);
          ctx.save();
          ctx.globalAlpha = 0.11;
          ctx.fillStyle = "#111827";
          ctx.font = "18px sans-serif";
          ctx.translate(w / 2, h / 2);
          ctx.rotate(-Math.PI / 5);
          const stamp = `${state.session.identity.fullName} | ${state.session.identity.studentId} | ${new Date().toLocaleTimeString()}`;
          for (let y = -h; y < h; y += 80) {
            const jitterX = (Math.random() - 0.5) * 60;
            ctx.fillText(stamp, -w + jitterX, y);
          }
          ctx.restore();
        }

        drawNoise();
        drawWatermark();
        noiseTimerId = setInterval(drawNoise, 500);
        watermarkTimerId = setInterval(drawWatermark, 3000);
        window.addEventListener("resize", () => {
          sizeCanvas(noiseCanvas);
          sizeCanvas(wmCanvas);
          drawNoise();
          drawWatermark();
        }, { once: true });
      }

      function timerBadgeClass(ms) {
        if (ms <= 2 * 60 * 1000) return "text-red-700 bg-red-100 border-red-300";
        if (ms <= 10 * 60 * 1000) return "text-amber-700 bg-amber-100 border-amber-300";
        return "text-emerald-700 bg-emerald-100 border-emerald-300";
      }

      function fmt(ms) {
        const t = Math.max(0, Math.floor(ms / 1000));
        const m = Math.floor(t / 60).toString().padStart(2, "0");
        const s = (t % 60).toString().padStart(2, "0");
        return `${m}:${s}`;
      }

      async function refreshAdminData() {
        const [banks, tests, results, analytics] = await Promise.all([
          adminApiFetch("/admin/banks"),
          adminApiFetch("/admin/tests"),
          adminApiFetch("/admin/results"),
          adminApiFetch("/admin/analytics/questions")
        ]);
        state.adminData.banks = banks;
        state.adminData.tests = tests;
        state.adminData.results = results;
        state.adminData.analytics = analytics;
      }

      function adminScreen() {
        const banks = state.adminData.banks || [];
        const usableBanks = banks.filter((b) => Number(b.question_count || 0) > 0);
        const tests = state.adminData.tests || [];
        const results = state.adminData.results || [];
        const analytics = state.adminData.analytics || [];
        const allocationRows = (state.adminDraft.allocations || []).map((a, i) => `
          <div class="grid grid-cols-12 gap-2 items-center mb-2" data-alloc-row="${i}">
            <select class="col-span-7 border rounded p-2 alloc-bank">
              <option value="">Select bank</option>
              ${banks.map((b) => `<option value="${escapeHtml(b.code)}" ${a.bankCode === b.code ? "selected" : ""} ${Number(b.question_count || 0) < 1 ? "disabled" : ""}>${escapeHtml(b.code)} (${b.question_count})</option>`).join("")}
            </select>
            <input type="number" min="1" class="col-span-3 border rounded p-2 alloc-count" value="${Number(a.count || 1)}">
            <button type="button" class="col-span-2 px-2 py-2 rounded bg-gray-200 remove-alloc">Remove</button>
          </div>
        `).join("");
        const allocTotal = (state.adminDraft.allocations || []).reduce((s, a) => s + Number(a.count || 0), 0);

        return `
          <div class="max-w-7xl mx-auto p-4 md:p-8 space-y-6">
            <div class="bg-white rounded-xl shadow p-4">
              <h1 class="text-2xl font-bold">Admin Panel</h1>
              <p class="text-sm text-gray-600">Test banks, test configuration, results, analytics</p>
              <button id="adminLogout" class="mt-2 px-3 py-2 rounded bg-gray-800 text-white">Logout</button>
              <button id="resetUploadedBtn" class="mt-2 ml-2 px-3 py-2 rounded bg-red-700 text-white">Reset Uploaded Data</button>
            </div>

            <div class="grid lg:grid-cols-2 gap-4">
              <div class="bg-white rounded-xl shadow p-4 space-y-3">
                <h2 class="text-xl font-semibold">Upload Test Bank (Aiken .txt)</h2>
                <label class="block text-sm">Bank code <input id="bankCodeInput" class="w-full border rounded p-2" value="${escapeHtml(state.adminDraft.bankCode || "")}" placeholder="anatomy_bank_a"></label>
                <label class="block text-sm">Bank name <input id="bankNameInput" class="w-full border rounded p-2" value="${escapeHtml(state.adminDraft.bankName || "")}" placeholder="Anatomy Bank A"></label>
                <label class="block text-sm">Mode
                  <select id="bankUploadMode" class="w-full border rounded p-2">
                    <option value="append" ${state.adminDraft.uploadMode === "append" ? "selected" : ""}>Append</option>
                    <option value="replace" ${state.adminDraft.uploadMode === "replace" ? "selected" : ""}>Replace</option>
                  </select>
                </label>
                <label class="block text-sm">Aiken file <input id="bankFileInput" type="file" accept=".txt,.aiken,text/plain" class="w-full border rounded p-2"></label>
                <button id="uploadBankBtn" class="px-3 py-2 rounded bg-indigo-700 text-white">Upload Bank</button>
                ${state.adminData.uploadSummary ? `<pre class="text-xs bg-gray-50 border rounded p-2 overflow-x-auto">${escapeHtml(JSON.stringify(state.adminData.uploadSummary, null, 2))}</pre>` : ""}
                <div class="text-sm text-gray-700">
                  <p class="font-semibold mb-1">Bank list</p>
                  ${(banks || []).map((b) => `<div class="flex items-center justify-between border rounded p-2 mb-2"><span>${escapeHtml(b.code)} - ${escapeHtml(b.name)} (${b.question_count})</span><span class="flex gap-2"><button data-clear-bank="${escapeHtml(b.code)}" class="px-2 py-1 rounded bg-amber-600 text-white text-xs">Clear Questions</button><button data-del-bank="${escapeHtml(b.code)}" class="px-2 py-1 rounded bg-red-600 text-white text-xs">Delete Bank</button></span></div>`).join("") || "<p>No banks yet.</p>"}
                </div>
              </div>

              <div class="bg-white rounded-xl shadow p-4 space-y-3">
                <h2 class="text-xl font-semibold">Create / Save Test Configuration</h2>
                <label class="block text-sm">Test name <input id="testNameInput" class="w-full border rounded p-2" value="${escapeHtml(state.adminDraft.testName || "")}" placeholder="Midterm March 2026"></label>
                <label class="block text-sm">Test code <input id="testCodeInput" class="w-full border rounded p-2" value="${escapeHtml(state.adminDraft.testCode || "")}" placeholder="MIDTERM-2026-03"></label>
                <div class="grid grid-cols-2 gap-2">
                  <label class="block text-sm">Total questions <input id="totalQuestionsInput" type="number" min="1" class="w-full border rounded p-2" value="${Number(state.adminDraft.totalQuestions || 10)}"></label>
                  <label class="block text-sm">Duration (minutes) <input id="durationInput" type="number" min="1" class="w-full border rounded p-2" value="${Number(state.adminDraft.durationMinutes || 60)}"></label>
                </div>
                <div class="grid grid-cols-2 gap-2">
                  <label class="block text-sm">Window start <input id="windowStartInput" type="datetime-local" class="w-full border rounded p-2" value="${escapeHtml(state.adminDraft.windowStart || "")}"></label>
                  <label class="block text-sm">Window end <input id="windowEndInput" type="datetime-local" class="w-full border rounded p-2" value="${escapeHtml(state.adminDraft.windowEnd || "")}"></label>
                </div>
                <div class="grid grid-cols-2 gap-2">
                  <label class="block text-sm">Status
                    <select id="testStatusInput" class="w-full border rounded p-2">
                      <option value="draft" ${state.adminDraft.status === "draft" ? "selected" : ""}>draft</option>
                      <option value="active" ${state.adminDraft.status === "active" ? "selected" : ""}>active</option>
                      <option value="closed" ${state.adminDraft.status === "closed" ? "selected" : ""}>closed</option>
                    </select>
                  </label>
                  <label class="block text-sm">Passcode <input id="testPasscodeInput" class="w-full border rounded p-2" value="${escapeHtml(state.adminDraft.passcode || "")}"></label>
                </div>
                <label class="flex items-center gap-2"><input id="resultsReleasedInput" type="checkbox" ${state.adminDraft.resultsReleased ? "checked" : ""}> Results released</label>
                <div>
                  <p class="font-semibold mb-2">Bank allocations</p>
                  <p class="text-xs text-gray-600 mb-2">Select any subset from each bank. Only the allocation total must match Total questions.</p>
                  ${usableBanks.length ? `<p class="text-xs text-emerald-700 mb-2">Using existing banks only. Upload is not required for every new test.</p>` : `<p class="text-xs text-red-700 mb-2">No question banks with questions are available. Upload a bank first.</p>`}
                  <div id="allocRows">${allocationRows}</div>
                  <button id="addAllocBtn" class="px-3 py-2 rounded bg-gray-200">Add Allocation Row</button>
                  <p class="text-xs mt-2">Allocation total: <strong id="allocTotal">${allocTotal}</strong></p>
                </div>
                <button id="saveTestBtn" class="px-3 py-2 rounded bg-blue-700 text-white ${usableBanks.length ? "" : "opacity-60 cursor-not-allowed"}" ${usableBanks.length ? "" : "disabled"}>Save Test Config</button>
              </div>
            </div>

            <div class="bg-white rounded-xl shadow p-4 space-y-2">
              <h2 class="text-xl font-semibold">Saved Test Configurations</h2>
              ${(tests || []).map((t) => `<div class="border rounded p-3 mb-2"><div class="font-semibold">${escapeHtml(t.code)} - ${escapeHtml(t.test_name || t.title)}</div><div class="text-sm text-gray-700">Questions: ${t.total_questions || t.draw_count}, Duration: ${t.duration_minutes}m, Window: ${new Date(t.window_start).toLocaleString()} → ${new Date(t.window_end).toLocaleString()}, Status: ${escapeHtml(t.status)}, Released: ${t.results_released ? "yes" : "no"}</div><div class="mt-2 flex gap-2"><button data-activate-test="${escapeHtml(t.code)}" class="px-2 py-1 rounded bg-emerald-700 text-white text-xs">Set Active</button><button data-close-test="${escapeHtml(t.code)}" class="px-2 py-1 rounded bg-slate-700 text-white text-xs">Set Closed</button><button data-release-test="${escapeHtml(t.code)}" class="px-2 py-1 rounded bg-indigo-700 text-white text-xs">${t.results_released ? "Hide Results" : "Release Results"}</button><button data-clear-test-attempts="${escapeHtml(t.code)}" class="px-2 py-1 rounded bg-amber-700 text-white text-xs">Clear Attempts</button><button data-delete-test="${escapeHtml(t.code)}" class="px-2 py-1 rounded bg-red-700 text-white text-xs">Delete Test</button></div></div>`).join("") || "<p>No test configs yet.</p>"}
            </div>

            <div class="bg-white rounded-xl shadow p-4 space-y-3">
              <h2 class="text-xl font-semibold">Results + Analytics</h2>
              <div class="flex gap-2 flex-wrap">
                <button id="refreshAdminBtn" class="px-3 py-2 rounded bg-slate-700 text-white">Refresh</button>
                <button id="exportResultsBtn" class="px-3 py-2 rounded bg-teal-700 text-white">Export CSV</button>
              </div>
              <div class="overflow-x-auto">
                <table class="w-full text-sm">
                  <thead class="bg-gray-100"><tr><th class="p-2 text-left">Student</th><th class="p-2 text-left">ID</th><th class="p-2 text-left">Score</th><th class="p-2 text-left">Violations</th><th class="p-2 text-left">Submitted</th></tr></thead>
                  <tbody>${results.map((r) => `<tr class="border-b"><td class="p-2">${escapeHtml(r.student_name)}</td><td class="p-2">${escapeHtml(r.student_id)}</td><td class="p-2">${r.score}/${r.total} (${r.percentage}%)</td><td class="p-2">${r.violation_count}</td><td class="p-2">${new Date(r.submitted_at).toLocaleString()}</td></tr>`).join("") || "<tr><td class='p-2 text-gray-500' colspan='5'>No results.</td></tr>"}</tbody>
                </table>
              </div>
              <div class="overflow-x-auto">
                <table class="w-full text-sm">
                  <thead class="bg-gray-100"><tr><th class="p-2 text-left">Bank</th><th class="p-2 text-left">Question</th><th class="p-2 text-left">Difficulty</th><th class="p-2 text-left">Topic</th><th class="p-2 text-left">Served</th><th class="p-2 text-left">Correct</th><th class="p-2 text-left">Correct %</th><th class="p-2 text-left">Choices</th></tr></thead>
                  <tbody>${analytics.map((a) => `<tr class="border-b"><td class="p-2">${escapeHtml(a.bank_name)}</td><td class="p-2">${escapeHtml(a.question_id)}</td><td class="p-2">${escapeHtml(a.difficulty)}</td><td class="p-2">${escapeHtml(a.topic_tag)}</td><td class="p-2">${a.served_count}</td><td class="p-2">${a.correct_count}</td><td class="p-2">${a.correct_percent}%</td><td class="p-2">${escapeHtml(JSON.stringify(a.choice_distribution || {}))}</td></tr>`).join("") || "<tr><td class='p-2 text-gray-500' colspan='8'>No analytics.</td></tr>"}</tbody>
                </table>
              </div>
            </div>
          </div>
        `;
      }

      function render() {
        clearVisualTimers();

        if (state.route === "admin") {
          if (!state.adminAuthed) {
            app.innerHTML = `
              <div class="max-w-md mx-auto p-6 mt-16 bg-white rounded-xl shadow space-y-4">
                <h1 class="text-2xl font-bold">Admin Login</h1>
                <input id="adminPass" type="password" class="w-full border rounded p-2" placeholder="Admin password">
                <button id="adminLogin" class="w-full py-2 rounded bg-gray-900 text-white">Login</button>
                <a href="#/login" class="text-blue-700 underline">Back to assessment</a>
              </div>
            `;
            document.getElementById("adminLogin").onclick = async () => {
              try {
                const response = await apiFetch("/admin/login", {
                  method: "POST",
                  body: { password: document.getElementById("adminPass").value || "" }
                });
                state.adminToken = response.token;
                state.adminAuthed = true;
                await refreshAdminData();
                render();
              } catch (err) {
                alert(`Invalid admin password or login blocked: ${err.message}`);
              }
            };
            return;
          }

          app.innerHTML = adminScreen();
          if (!(state.adminData.banks || []).length && state.adminToken) {
            refreshAdminData().then(() => render()).catch(() => {});
          }

          const readAllocationsFromDom = () => {
            const allocRows = [...document.querySelectorAll("[data-alloc-row]")];
            const rows = allocRows.map((row) => ({
              bankCode: sanitizeInput(row.querySelector(".alloc-bank")?.value || ""),
              count: Number(row.querySelector(".alloc-count")?.value || 0)
            })).filter((r) => r.bankCode && Number.isInteger(r.count) && r.count > 0);
            return rows.length ? rows : [{ bankCode: "", count: 1 }];
          };

          const captureAdminDraftFromForm = (includeAllocations = true) => {
            const next = normalizeAdminDraft({
              ...state.adminDraft,
              bankCode: sanitizeInput(document.getElementById("bankCodeInput")?.value || state.adminDraft.bankCode),
              bankName: sanitizeInput(document.getElementById("bankNameInput")?.value || state.adminDraft.bankName),
              uploadMode: document.getElementById("bankUploadMode")?.value || state.adminDraft.uploadMode,
              testName: sanitizeInput(document.getElementById("testNameInput")?.value || state.adminDraft.testName),
              testCode: sanitizeInput(document.getElementById("testCodeInput")?.value || state.adminDraft.testCode),
              totalQuestions: Number(document.getElementById("totalQuestionsInput")?.value || state.adminDraft.totalQuestions),
              durationMinutes: Number(document.getElementById("durationInput")?.value || state.adminDraft.durationMinutes),
              windowStart: document.getElementById("windowStartInput")?.value || state.adminDraft.windowStart,
              windowEnd: document.getElementById("windowEndInput")?.value || state.adminDraft.windowEnd,
              status: document.getElementById("testStatusInput")?.value || state.adminDraft.status,
              resultsReleased: !!document.getElementById("resultsReleasedInput")?.checked,
              passcode: sanitizeInput(document.getElementById("testPasscodeInput")?.value || state.adminDraft.passcode),
              allocations: includeAllocations ? readAllocationsFromDom() : state.adminDraft.allocations
            });
            state.adminDraft = next;
            persistAdminDraft();
            return next;
          };

          const applyBankCodeAutoPopulate = () => {
            const raw = document.getElementById("bankCodeInput")?.value || "";
            const suggested = deriveAdminFieldsFromBankCode(raw);
            state.adminDraft = normalizeAdminDraft({
              ...state.adminDraft,
              ...suggested
            });
            persistAdminDraft();
            render();
          };

          const persistDraftOnly = () => {
            captureAdminDraftFromForm(true);
          };

          const bankCodeInput = document.getElementById("bankCodeInput");
          if (bankCodeInput) {
            bankCodeInput.onchange = applyBankCodeAutoPopulate;
            bankCodeInput.onblur = applyBankCodeAutoPopulate;
          }

          const draftPersistInputs = [
            "bankNameInput",
            "bankUploadMode",
            "testNameInput",
            "testCodeInput",
            "totalQuestionsInput",
            "durationInput",
            "windowStartInput",
            "windowEndInput",
            "testStatusInput",
            "resultsReleasedInput",
            "testPasscodeInput"
          ];
          draftPersistInputs.forEach((id) => {
            const el = document.getElementById(id);
            if (!el) return;
            el.onchange = persistDraftOnly;
            if (el.tagName === "INPUT" || el.tagName === "TEXTAREA") {
              el.oninput = persistDraftOnly;
            }
          });

          document.getElementById("adminLogout").onclick = () => {
            state.adminAuthed = false;
            state.adminToken = "";
            render();
          };
          document.getElementById("resetUploadedBtn").onclick = async () => {
            const value = prompt("Type RESET to clear uploaded banks/tests/results from staging:");
            if (value !== "RESET") return;
            try {
              const out = await adminApiFetch("/admin/reset-uploaded-data", {
                method: "POST",
                body: { confirm: "RESET" }
              });
              state.adminData.uploadSummary = out.summary || null;
              await refreshAdminData();
              render();
            } catch (err) {
              alert(`Reset failed: ${humanizeError(err)}`);
            }
          };
          document.getElementById("refreshAdminBtn").onclick = async () => {
            try {
              await refreshAdminData();
              render();
            } catch (err) {
              alert(`Unable to refresh admin data: ${err.message}`);
            }
          };
          const updateAllocUi = () => {
            const totalQuestions = Number(document.getElementById("totalQuestionsInput")?.value || 0);
            const allocations = readAllocationsFromDom();
            state.adminDraft.allocations = allocations;
            persistAdminDraft();
            const sum = allocations.reduce((s, a) => s + a.count, 0);
            const totalEl = document.getElementById("allocTotal");
            if (totalEl) totalEl.textContent = String(sum);
            const saveBtn = document.getElementById("saveTestBtn");
            if (saveBtn) {
              const bankCount = new Map((state.adminData.banks || []).map((b) => [String(b.code), Number(b.question_count || 0)]));
              const hasUsableBanks = [...bankCount.values()].some((c) => c > 0);
              const banksValid = allocations.every((a) => {
                const available = bankCount.get(String(a.bankCode)) || 0;
                return available > 0 && a.count <= available;
              });
              const ok = hasUsableBanks && banksValid && sum === totalQuestions && totalQuestions > 0;
              saveBtn.disabled = !ok;
              saveBtn.className = `px-3 py-2 rounded text-white ${ok ? "bg-blue-700" : "bg-gray-400 cursor-not-allowed"}`;
            }
          };
          document.getElementById("addAllocBtn").onclick = () => {
            state.adminDraft.allocations = (state.adminDraft.allocations || []).concat([{ bankCode: "", count: 1 }]);
            persistAdminDraft();
            render();
          };
          document.querySelectorAll(".alloc-count").forEach((el) => { el.oninput = updateAllocUi; });
          document.querySelectorAll(".alloc-bank").forEach((el) => { el.onchange = updateAllocUi; });
          const totalInput = document.getElementById("totalQuestionsInput");
          if (totalInput) totalInput.oninput = updateAllocUi;
          updateAllocUi();
          document.querySelectorAll(".remove-alloc").forEach((btn) => {
            btn.onclick = () => {
              const row = btn.closest("[data-alloc-row]");
              const index = Number(row?.getAttribute("data-alloc-row"));
              state.adminDraft.allocations = (state.adminDraft.allocations || []).filter((_, i) => i !== index);
              if (!state.adminDraft.allocations.length) state.adminDraft.allocations = [{ bankCode: "", count: 1 }];
              persistAdminDraft();
              render();
            };
          });
          document.querySelectorAll("[data-del-bank]").forEach((btn) => {
            btn.onclick = async () => {
              const code = btn.getAttribute("data-del-bank");
              if (!confirm(`Delete bank '${code}'?`)) return;
              try {
                await adminApiFetch(`/admin/banks/${encodeURIComponent(code)}`, { method: "DELETE" });
                await refreshAdminData();
                render();
              } catch (err) {
                alert(`Unable to delete bank: ${humanizeError(err)}`);
              }
            };
          });
          document.querySelectorAll("[data-clear-bank]").forEach((btn) => {
            btn.onclick = async () => {
              const code = btn.getAttribute("data-clear-bank");
              if (!confirm(`Clear all questions from bank '${code}'?`)) return;
              try {
                await adminApiFetch(`/admin/banks/${encodeURIComponent(code)}/clear`, { method: "POST" });
                await refreshAdminData();
                render();
              } catch (err) {
                alert(`Unable to clear bank: ${humanizeError(err)}`);
              }
            };
          });
          document.getElementById("uploadBankBtn").onclick = async () => {
            const fileEl = document.getElementById("bankFileInput");
            const file = fileEl.files && fileEl.files[0];
            if (!file) {
              alert("Please choose an Aiken text file.");
              return;
            }
            const fileText = await file.text();
            const bankCode = sanitizeInput(document.getElementById("bankCodeInput").value);
            const bankName = sanitizeInput(document.getElementById("bankNameInput").value);
            const mode = document.getElementById("bankUploadMode").value;
            state.adminDraft = normalizeAdminDraft({
              ...state.adminDraft,
              bankCode,
              bankName,
              uploadMode: mode
            });
            persistAdminDraft();
            try {
              const response = await adminApiFetch("/admin/banks/upload", {
                method: "POST",
                body: { bankCode, bankName, mode, fileText }
              });
              state.adminData.uploadSummary = response.summary || null;
              await refreshAdminData();
              render();
            } catch (err) {
              alert(`Upload failed: ${humanizeError(err)}`);
            }
          };
          document.getElementById("saveTestBtn").onclick = async () => {
            const allocations = readAllocationsFromDom();
            const bankCount = new Map((state.adminData.banks || []).map((b) => [String(b.code), Number(b.question_count || 0)]));
            const hasUsableBanks = [...bankCount.values()].some((c) => c > 0);
            if (!hasUsableBanks) {
              alert("Cannot save test: no question banks with questions are available.");
              return;
            }
            for (const a of allocations) {
              const available = bankCount.get(String(a.bankCode)) || 0;
              if (available < 1) {
                alert(`Cannot save test: bank '${a.bankCode}' has no questions.`);
                return;
              }
              if (a.count > available) {
                alert(`Cannot save test: bank '${a.bankCode}' only has ${available} questions, but ${a.count} requested.`);
                return;
              }
            }

            const payload = {
              testName: sanitizeInput(document.getElementById("testNameInput").value),
              code: sanitizeInput(document.getElementById("testCodeInput").value),
              totalQuestions: Number(document.getElementById("totalQuestionsInput").value || 0),
              durationMinutes: Number(document.getElementById("durationInput").value || 0),
              windowStart: localDateTimeInputToIso(document.getElementById("windowStartInput").value),
              windowEnd: localDateTimeInputToIso(document.getElementById("windowEndInput").value),
              status: document.getElementById("testStatusInput").value,
              resultsReleased: document.getElementById("resultsReleasedInput").checked,
              passcode: sanitizeInput(document.getElementById("testPasscodeInput").value),
              bankAllocations: allocations
            };
            state.adminDraft = normalizeAdminDraft({
              ...state.adminDraft,
              bankCode: sanitizeInput(document.getElementById("bankCodeInput").value),
              bankName: sanitizeInput(document.getElementById("bankNameInput").value),
              uploadMode: document.getElementById("bankUploadMode").value,
              testName: payload.testName,
              testCode: payload.code,
              totalQuestions: payload.totalQuestions,
              durationMinutes: payload.durationMinutes,
              windowStart: document.getElementById("windowStartInput").value || "",
              windowEnd: document.getElementById("windowEndInput").value || "",
              status: payload.status,
              resultsReleased: payload.resultsReleased,
              passcode: payload.passcode,
              allocations
            });
            persistAdminDraft();

            if (allocations.reduce((s, a) => s + a.count, 0) !== payload.totalQuestions) {
              alert("Allocation total must equal total questions.");
              return;
            }
            try {
              const exists = (state.adminData.tests || []).some(
                (t) => String(t.code || "").toLowerCase() === String(payload.code || "").toLowerCase()
              );
              if (exists) {
                await adminApiFetch(`/admin/tests/${encodeURIComponent(payload.code)}`, { method: "PUT", body: payload });
              } else {
                await adminApiFetch("/admin/tests", { method: "POST", body: payload });
              }
              await refreshAdminData();
              render();
            } catch (err) {
              alert(`Unable to save test: ${humanizeError(err)}`);
            }
          };
          document.querySelectorAll("[data-activate-test]").forEach((btn) => {
            btn.onclick = async () => {
              try {
                await adminApiFetch(`/admin/tests/${encodeURIComponent(btn.getAttribute("data-activate-test"))}/status`, {
                  method: "POST",
                  body: { status: "active" }
                });
                await refreshAdminData();
                render();
              } catch (err) {
                alert(`Unable to activate test: ${humanizeError(err)}`);
              }
            };
          });
          document.querySelectorAll("[data-close-test]").forEach((btn) => {
            btn.onclick = async () => {
              try {
                await adminApiFetch(`/admin/tests/${encodeURIComponent(btn.getAttribute("data-close-test"))}/status`, {
                  method: "POST",
                  body: { status: "closed" }
                });
                await refreshAdminData();
                render();
              } catch (err) {
                alert(`Unable to close test: ${humanizeError(err)}`);
              }
            };
          });
          document.querySelectorAll("[data-release-test]").forEach((btn) => {
            btn.onclick = async () => {
              const code = btn.getAttribute("data-release-test");
              const test = (state.adminData.tests || []).find((t) => t.code === code);
              const willRelease = !(test?.results_released);
              try {
                const updated = await adminApiFetch(`/admin/tests/${encodeURIComponent(code)}/release`, {
                  method: "POST",
                  body: { resultsReleased: willRelease }
                });
                if (willRelease && updated?.notificationSummary) {
                  const s = updated.notificationSummary;
                  alert(`Results released.\nEmail notifications: sent ${s.notified}, skipped ${s.skipped}, failed ${s.failed}.`);
                }
                await refreshAdminData();
                render();
              } catch (err) {
                alert(`Unable to update results release: ${humanizeError(err)}`);
              }
            };
          });
          document.querySelectorAll("[data-delete-test]").forEach((btn) => {
            btn.onclick = async () => {
              const code = btn.getAttribute("data-delete-test");
              if (!confirm(`Delete test '${code}' and its sessions/results?`)) return;
              try {
                await adminApiFetch(`/admin/tests/${encodeURIComponent(code)}`, { method: "DELETE" });
                await refreshAdminData();
                render();
              } catch (err) {
                alert(`Unable to delete test: ${humanizeError(err)}`);
              }
            };
          });
          document.querySelectorAll("[data-clear-test-attempts]").forEach((btn) => {
            btn.onclick = async () => {
              const code = btn.getAttribute("data-clear-test-attempts");
              if (!confirm(`Clear all attempts/results for test '${code}' but keep the config?`)) return;
              try {
                await adminApiFetch(`/admin/tests/${encodeURIComponent(code)}/clear-attempts`, { method: "POST" });
                await refreshAdminData();
                render();
              } catch (err) {
                alert(`Unable to clear attempts: ${humanizeError(err)}`);
              }
            };
          });
          document.getElementById("exportResultsBtn").onclick = async () => {
            try {
              const res = await fetch(`${API_BASE}/admin/results.csv`, {
                headers: { Authorization: `Bearer ${state.adminToken}` }
              });
              const content = await res.text();
              if (!res.ok) throw new Error(content || "export_failed");
              download("results.csv", content, "text/csv");
            } catch (err) {
              alert(`Export failed: ${err.message}`);
            }
          };
          return;
        }

        if (state.route === "released-results") {
          const access = state.publicResultAccessToken || "";
          if (!state.publicResult.loading && !state.publicResult.payload && !state.publicResult.error) {
            fetchPublicReleasedResult(access);
          }

          const pr = state.publicResult;
          const result = pr.payload || null;
          app.innerHTML = `
            <div class="max-w-4xl mx-auto p-4 md:p-8 space-y-4">
              <div class="bg-white rounded-xl shadow p-6">
                <h1 class="text-2xl font-bold">Released Assessment Results</h1>
                ${pr.loading ? `<p class="mt-3 text-sm text-gray-600">Loading results...</p>` : ""}
                ${pr.error ? `<p class="mt-3 text-sm font-semibold text-red-700">${escapeHtml(pr.error)}</p>` : ""}
                ${result ? `
                  <p class="mt-2">Student: <strong>${escapeHtml(result.student?.fullName || "")}</strong> (${escapeHtml(result.student?.studentId || "")})</p>
                  <p>Assessment: <strong>${escapeHtml(result.assessmentTitle || result.assessmentCode || "")}</strong></p>
                  <p class="mt-2">Score: <strong>${result.score} / ${result.total}</strong> (${result.percentage}%)</p>
                  <p>Submitted: <strong>${new Date(result.submittedAt).toLocaleString()}</strong></p>
                ` : ""}
                <div class="mt-4">
                  <a href="#/login" class="px-4 py-2 rounded bg-blue-700 text-white inline-block">Back to Assessment</a>
                </div>
              </div>
              ${result && Array.isArray(result.details) ? `
              <div class="bg-white rounded-xl shadow p-6">
                <h2 class="text-xl font-semibold mb-2">Question Review</h2>
                ${result.details.map((d, i) => `<div class='border rounded p-3 mb-2'>
                  <div class='font-semibold'>Q${i + 1}: ${escapeHtml(d.stem || "")}</div>
                  <div class='text-sm mt-1'>Your answer: ${escapeHtml(d.selectedText || "Unanswered")}</div>
                  <div class='text-sm'>Correct answer: ${escapeHtml(d.correctText || "")}</div>
                  <div class='text-xs text-gray-600 mt-1'>${escapeHtml(d.explanation || "")}</div>
                </div>`).join("")}
              </div>` : ""}
            </div>
          `;
          return;
        }

        if (state.route === "login") {
          const noticeText = state.activeAssessment?.integrity_notice || INTEGRITY_NOTICE;
          app.innerHTML = `
            <div class="max-w-3xl mx-auto p-4 md:p-8 space-y-4">
              <div class="bg-white rounded-xl shadow p-5">
                <h1 class="text-3xl font-bold">${escapeHtml(state.config.title)}</h1>
                <p class="text-gray-600 mt-1">Secure, sequential, monitored MCQ assessment</p>
              </div>
              <div class="bg-white rounded-xl shadow p-5 space-y-3">
                <h2 class="text-xl font-semibold">Identity Capture</h2>
                <input id="fullName" class="w-full border rounded p-2" placeholder="Full Name">
                <input id="studentId" class="w-full border rounded p-2" placeholder="Student/Employee ID">
                <input id="studentEmail" type="text" class="w-full border rounded p-2" placeholder="Email address (for result notification)">
                <input id="assessmentCode" class="w-full border rounded p-2" placeholder="Assessment Code (default: ASSESS-2026)">
                <input id="passcode" class="w-full border rounded p-2" placeholder="Assessment Passcode (if required)">
                <label class="flex items-start gap-2 text-sm"><input id="honesty" type="checkbox" class="mt-1">I confirm I will complete this assessment honestly and without assistance.</label>
                <pre class="whitespace-pre-wrap text-sm bg-gray-50 border rounded p-3">${escapeHtml(noticeText)}</pre>
                <button id="toRules" class="w-full py-2 rounded bg-blue-700 text-white">Continue</button>
                <a href="#/admin" class="text-blue-700 underline">Admin</a>
              </div>
            </div>
          `;
          document.getElementById("toRules").onclick = () => {
            const fullName = sanitizeInput(document.getElementById("fullName").value);
            const studentId = sanitizeInput(document.getElementById("studentId").value);
            const email = sanitizeInput(document.getElementById("studentEmail").value);
            const assessmentCode = sanitizeInput(document.getElementById("assessmentCode").value) || "ASSESS-2026";
            const passcode = sanitizeInput(document.getElementById("passcode").value);
            const honest = document.getElementById("honesty").checked;

            if (!fullName || !studentId || !honest) {
              alert("Please complete name, ID, and honesty confirmation.");
              return;
            }
            state.pendingIdentity = { fullName, studentId, email, assessmentCode, passcode };
            state.route = "rules";
            render();
          };
          return;
        }

        if (state.route === "rules") {
          const noticeText = state.activeAssessment?.integrity_notice || INTEGRITY_NOTICE;
          app.innerHTML = `
            <div class="max-w-3xl mx-auto p-4 md:p-8">
              <div class="bg-white rounded-xl shadow p-6 space-y-4">
                <h1 class="text-2xl font-bold">Assessment Rules</h1>
                <ul class="list-disc ml-5 text-sm space-y-1">
                  <li>Number of questions: ${state.config.drawCount}</li>
                  <li>Time allowed: ${state.config.timeLimitMinutes} minutes</li>
                  <li>Tab/window switching events are logged and may trigger auto-submit</li>
                  <li>No back navigation between questions</li>
                  <li>Anti-cheating monitoring and watermarking are active</li>
                </ul>
                <pre class="whitespace-pre-wrap text-sm bg-gray-50 border rounded p-3">${escapeHtml(noticeText)}</pre>
                <button id="startAssessment" class="w-full py-3 rounded bg-green-700 text-white font-semibold">Start Assessment</button>
              </div>
            </div>
          `;
          document.getElementById("startAssessment").onclick = () => startAssessment(state.pendingIdentity);
          return;
        }

        if (state.route === "assessment" && state.session) {
          const q = currentQuestion();
          if (!q) return;
          const n = Number(state.currentQuestionPayload?.totalQuestions || state.config.drawCount || 0);
          const idx = Number(state.currentQuestionPayload?.questionIndex || 0) + 1;
          app.innerHTML = `
            <header class="sticky top-0 z-40 border-b bg-white/95 backdrop-blur">
              <div class="max-w-5xl mx-auto px-3 py-2 flex items-center justify-between gap-2 text-sm">
                <div class="font-semibold truncate">${escapeHtml(state.session.identity.fullName)} | ${escapeHtml(state.config.title)}</div>
                <div class="px-2 py-1 border rounded ${timerBadgeClass(state.timer.remainingMs)}">${fmt(state.timer.remainingMs)}</div>
                <div class="px-2 py-1 border rounded text-slate-700 bg-slate-100 border-slate-300">Window ${fmt(state.timer.windowRemainingMs)}</div>
                <div>Question ${idx} of ${n}</div>
                ${state.config.fullscreenEnforcement && !document.fullscreenElement ? `<button id="enterFsBtn" class="px-2 py-1 rounded bg-slate-700 text-white text-xs">Enter Fullscreen</button>` : ""}
              </div>
            </header>

            <main class="max-w-5xl mx-auto p-3 md:p-6 no-select">
              ${state.ui.zoomWarning ? `<div class='mb-3 p-3 rounded border bg-amber-50 border-amber-300 text-amber-800 text-sm'>Zoom appears not at 100%. Please reset browser zoom for optimal display.</div>` : ""}
              <section id="questionCard" class="assessment-block relative bg-white rounded-xl shadow p-4 md:p-6 overflow-hidden" style="--hatch-angle:${15 + Math.floor(Math.random() * 31)}deg;">
                <canvas id="noiseCanvas" class="absolute inset-0 z-10 pointer-events-none"></canvas>
                <canvas id="wmCanvas" class="absolute inset-0 z-20 pointer-events-none"></canvas>
                <div class="ocr-grid-overlay"></div>
                <div class="relative z-30">
                  ${q.image ? `<img alt='question image' src='${escapeHtml(q.image)}' class='mb-3 max-h-72 w-full object-contain rounded border' />` : ""}
                  <h2 class="text-xl md:text-2xl font-semibold leading-snug">${escapeHtml(q.stem)}</h2>
                  <div class="mt-4 space-y-2">
                    ${(q.options || []).map(d => `
                      <button type="button" data-option="${escapeHtml(d.originalId)}" class="option-btn relative z-40 w-full text-left border rounded-lg px-4 py-3 bg-white/90 hover:bg-slate-50 ${state.selectedOptionId === d.originalId ? "border-blue-600 ring-2 ring-blue-200" : "border-gray-300"}">
                        <span class="font-semibold mr-2">${d.displayLabel}.</span>${escapeHtml(d.text)}
                      </button>
                    `).join("")}
                  </div>
                  <button id="nextBtn" type="button" class="relative z-40 mt-5 w-full md:w-auto px-6 py-3 rounded font-semibold ${(state.selectedOptionId && !state.ui.advancing) ? "bg-blue-700 text-white" : "bg-gray-300 text-gray-600 cursor-not-allowed"}" ${(state.selectedOptionId && !state.ui.advancing) ? "" : "disabled"}>${state.ui.advancing ? "Submitting..." : (idx === n ? "Submit" : "Next Question")}</button>
                </div>
              </section>
            </main>

            ${state.ui.overlay ? `<div class='fixed inset-0 z-50 bg-black/60 flex items-center justify-center p-4'><div class='max-w-md w-full bg-white rounded-xl p-5'><h3 class='text-lg font-bold mb-2'>Security Warning</h3><p class='text-sm'>${escapeHtml(state.ui.overlay)}</p><button id='dismissOverlay' class='mt-4 w-full py-2 rounded bg-red-700 text-white'>I Understand</button></div></div>` : ""}
            ${state.ui.inactivityOverlay ? `<div class='fixed inset-0 z-50 bg-black/70 flex items-center justify-center p-4'><div class='max-w-md w-full bg-white rounded-xl p-5'><h3 class='text-lg font-bold mb-2'>Are you still there?</h3><p class='text-sm'>No activity detected for 60 seconds. Timer continues running.</p><button id='resumeBtn' class='mt-4 w-full py-2 rounded bg-blue-700 text-white'>Continue Assessment</button></div></div>` : ""}
          `;

          startNoiseAndWatermark();
          rerollHatchAngle();
          // Robust option capture for full-row taps/clicks.
          const questionCard = document.getElementById("questionCard");
          if (questionCard) {
            questionCard.onpointerdown = (e) => {
              const btn = e.target.closest("[data-option]");
              if (!btn) return;
              state.selectedOptionId = btn.getAttribute("data-option");
              render();
            };
          }
          document.querySelectorAll("[data-option]").forEach((btn) => {
            btn.onpointerdown = () => {
              state.selectedOptionId = btn.getAttribute("data-option");
              render();
            };
          });
          document.getElementById("nextBtn").onpointerdown = () => nextQuestion();
          const fsBtn = document.getElementById("enterFsBtn");
          if (fsBtn) fsBtn.onclick = () => requestFullscreenIfEnabled();
          const d = document.getElementById("dismissOverlay");
          if (d) d.onclick = () => { state.ui.overlay = null; render(); };
          const r = document.getElementById("resumeBtn");
          if (r) r.onclick = () => { state.ui.inactivityOverlay = false; lastActivityAt = Date.now(); resetInactivity(); render(); };
          return;
        }

        if (state.route === "results" && state.results.length) {
          const r = state.results[0];
          const hasReleasedResults = Number.isInteger(r.score) && Array.isArray(r.details) && r.details.length >= 0 && r.resultsReleased !== false;
          app.innerHTML = `
            <div class="max-w-4xl mx-auto p-4 md:p-8 space-y-4">
              <div class="bg-white rounded-xl shadow p-6">
                <h1 class="text-2xl font-bold">Assessment Results</h1>
                ${hasReleasedResults ? `<p class="mt-2">Score: <strong>${r.score} / ${r.total}</strong> (${r.percentage}%)</p>` : `<p class="mt-2 text-amber-700 font-semibold">${escapeHtml(r.pendingMessage || "Results are pending admin release.")}</p>`}
                <p>Time taken: <strong>${Math.round(r.timeTakenMs / 1000)} seconds</strong></p>
                <p>Violation flags: <strong>${r.violationCount}</strong></p>
                <p class="text-sm text-gray-600 mt-2">Assessment Reference Number: <code>${escapeHtml(r.token)}</code></p>
                <div class="mt-3">
                  ${hasReleasedResults ? `<button id="downloadResultsJson" class="px-4 py-2 rounded bg-gray-900 text-white">Download Results (JSON)</button>
                  <button id="downloadReviewCsv" class="ml-2 px-4 py-2 rounded bg-slate-700 text-white">Download Review (CSV)</button>` : `<button id="checkReleasedBtn" class="px-4 py-2 rounded bg-blue-700 text-white">Check Released Results</button>`}
                  <button id="exitAssessment" class="ml-2 px-4 py-2 rounded bg-red-700 text-white">Exit</button>
                </div>
              </div>

              <div class="bg-white rounded-xl shadow p-6">
                <h2 class="text-xl font-semibold mb-2">Violation Log</h2>
                <pre class="text-xs bg-gray-50 border rounded p-3 overflow-x-auto">${escapeHtml(JSON.stringify(r.violations, null, 2))}</pre>
              </div>

              ${state.config.showPostReview && hasReleasedResults ? `<div class='bg-white rounded-xl shadow p-6'><h2 class='text-xl font-semibold mb-2'>Question Review</h2>${r.details.map((d, i) => `<div class='border rounded p-3 mb-2'><div class='font-semibold'>Q${i+1}: ${escapeHtml(d.stem)}</div><div class='text-sm mt-1'>Your answer: ${escapeHtml(d.selectedText || d.selected)}</div><div class='text-sm'>Correct answer: ${escapeHtml(d.correctText || d.correct)}</div><div class='text-xs text-gray-600 mt-1'>${escapeHtml(d.explanation)}</div></div>`).join("")}</div>` : ""}
            </div>
          `;
          const dlJson = document.getElementById("downloadResultsJson");
          if (dlJson) {
            dlJson.onclick = () => {
              const payload = buildResultExportPayload(r);
              download(`results-${r.token}.json`, JSON.stringify(payload, null, 2), "application/json");
            };
          }
          const dlCsv = document.getElementById("downloadReviewCsv");
          if (dlCsv) {
            dlCsv.onclick = () => {
              const csv = buildReviewCsv(r);
              download(`review-${r.token}.csv`, csv, "text/csv");
            };
          }
          const checkBtn = document.getElementById("checkReleasedBtn");
          if (checkBtn) {
            checkBtn.onclick = async () => {
              try {
                const released = await sessionApiFetch(`/session/${state.session.token}/result`);
                state.currentResult = {
                  ...released,
                  resultsReleased: true,
                  violations: state.violations.slice(),
                  violationCount: state.violations.length
                };
                state.results[0] = state.currentResult;
                saveJSON("mcq_results", state.results);
                render();
              } catch (err) {
                alert(err.code === "results_not_released" ? "Results are still not released." : `Unable to fetch results: ${err.message}`);
              }
            };
          }
          document.getElementById("exitAssessment").onclick = () => {
            const sid = String(r.student?.studentId || "");
            if (sid && !(state.exitedIds || []).includes(sid)) {
              state.exitedIds = (state.exitedIds || []).concat([sid]);
              saveJSON("mcq_exited_ids", state.exitedIds);
            }
            state.session = null;
            app.innerHTML = `<div class="max-w-xl mx-auto mt-24 bg-white rounded-xl shadow p-6 text-center"><h1 class="text-2xl font-bold">Assessment Closed</h1><p class="mt-2 text-gray-700">This session has ended. You can now close this tab.</p></div>`;
            setTimeout(() => {
              window.location.replace("about:blank");
            }, 250);
          };
          return;
        }
      }

      function buildResultExportPayload(result) {
        return {
          assessmentReference: result.token,
          submittedAt: result.submittedAt,
          student: result.student,
          summary: {
            score: result.score,
            total: result.total,
            percentage: result.percentage,
            timeTakenMs: result.timeTakenMs,
            autoSubmitted: !!result.autoSubmitted
          },
          violations: result.violations || [],
          questionReview: result.details || []
        };
      }

      function csvCell(v) {
        return `"${String(v ?? "").replace(/"/g, "\"\"")}"`;
      }

      function buildReviewCsv(result) {
        const lines = [
          "questionNumber,questionId,stem,selectedAnswer,correctAnswer,isCorrect,explanation"
        ];
        (result.details || []).forEach((d, i) => {
          lines.push([
            i + 1,
            d.questionId || "",
            csvCell(d.stem),
            csvCell(d.selectedText || d.selected),
            csvCell(d.correctText || d.correct),
            d.isCorrect ? "true" : "false",
            csvCell(d.explanation)
          ].join(","));
        });
        return lines.join("\n");
      }

      function download(name, content, type) {
        const blob = new Blob([content], { type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = name;
        a.click();
        URL.revokeObjectURL(url);
      }

      render();
      loadActiveAssessment().then(() => render()).catch(() => {});
    })();
  </script>
</body>
</html>
