<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Keccak Interactive Model</title>
    <style>
      :root {
        --bg: #f4f1e8;
        --panel: #fffdf8;
        --ink: #1f2a44;
        --muted: #5b6a83;
        --accent: #006d77;
        --accent-2: #ee9b00;
        --border: #d7d2c7;
        --changed: #ffd6a5;
        --selected: #94d2bd;
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        font-family: "Avenir Next", "Trebuchet MS", "Segoe UI", sans-serif;
        color: var(--ink);
        background:
          radial-gradient(circle at 18% 15%, #fff4c2 0%, transparent 32%),
          radial-gradient(circle at 85% 10%, #bfe6ea 0%, transparent 28%),
          linear-gradient(140deg, #faf7ef 0%, #ece8de 100%);
      }

      .shell {
        width: min(1200px, 94vw);
        margin: 22px auto 30px;
      }

      .hero {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 18px 20px;
      }

      .hero h1 {
        margin: 0 0 6px;
        font-size: clamp(1.4rem, 1.1rem + 1.3vw, 2.1rem);
        letter-spacing: 0.01em;
      }

      .hero p {
        margin: 0;
        color: var(--muted);
        line-height: 1.45;
      }

      .layout {
        margin-top: 14px;
        display: grid;
        grid-template-columns: 1fr 1.45fr;
        gap: 14px;
      }

      .panel {
        background: var(--panel);
        border: 1px solid var(--border);
        border-radius: 16px;
        padding: 16px;
      }

      .section-title {
        margin: 0 0 10px;
        font-size: 0.95rem;
        text-transform: uppercase;
        letter-spacing: 0.07em;
        color: #3f4e6a;
      }

      label {
        font-size: 0.84rem;
        font-weight: 700;
        color: #30405e;
      }

      textarea,
      input,
      select,
      button {
        font: inherit;
      }

      textarea,
      input,
      select {
        width: 100%;
        border: 1px solid #bdc3d1;
        border-radius: 10px;
        padding: 9px 11px;
        margin-top: 6px;
        margin-bottom: 10px;
        background: #ffffff;
      }

      textarea {
        min-height: 86px;
        resize: vertical;
      }

      .row {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 10px;
      }

      .row-4 {
        display: grid;
        grid-template-columns: repeat(4, 1fr);
        gap: 8px;
      }

      .actions {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        margin-top: 4px;
      }

      button {
        border: 0;
        border-radius: 10px;
        padding: 8px 13px;
        cursor: pointer;
        background: #dbe3f3;
        color: #1f2a44;
        font-weight: 700;
      }

      button.primary {
        background: var(--accent);
        color: white;
      }

      button.warn {
        background: var(--accent-2);
      }

      .badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 999px;
        font-size: 0.75rem;
        background: #ebedf0;
        margin-right: 6px;
        margin-bottom: 4px;
      }

      .mono {
        font-family: "IBM Plex Mono", "SFMono-Regular", Menlo, monospace;
      }

      .digest {
        margin-top: 8px;
        border: 1px dashed #bcc4d3;
        border-radius: 10px;
        padding: 8px;
        background: #f7f9fc;
        word-break: break-all;
      }

      #status {
        min-height: 20px;
        color: #8a1c1c;
        font-weight: 700;
      }

      .slider-wrap {
        margin-top: 12px;
      }

      .slider-wrap input {
        margin-bottom: 4px;
      }

      .step-title {
        margin: 6px 0 4px;
        font-weight: 700;
      }

      .step-sub {
        margin: 0 0 10px;
        color: var(--muted);
      }

      .sponge {
        display: grid;
        grid-template-columns: repeat(3, 1fr);
        gap: 10px;
        margin-bottom: 12px;
      }

      .sponge-box {
        border: 1px solid #c9cfdb;
        border-radius: 12px;
        padding: 10px;
        text-align: center;
        background: #f3f5f9;
      }

      .sponge-box.active {
        border-color: #2a6f97;
        background: #d9eff8;
      }

      .sponge-box.current {
        border-color: #0d3b66;
        box-shadow: 0 0 0 2px #9fd4e8 inset;
      }

      .grid-wrap {
        border: 1px solid #c9cfdb;
        border-radius: 12px;
        padding: 10px;
        background: #fbfcff;
      }

      .legend {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
        font-size: 0.77rem;
        color: #33415c;
        margin-bottom: 8px;
      }

      .dot {
        width: 12px;
        height: 12px;
        display: inline-block;
        border-radius: 3px;
        vertical-align: middle;
        margin-right: 4px;
      }

      .lane-grid {
        display: grid;
        grid-template-columns: repeat(5, minmax(90px, 1fr));
        gap: 8px;
      }

      .lane {
        border: 1px solid #c6cfde;
        border-radius: 10px;
        padding: 8px;
        background: white;
        cursor: pointer;
        transition: transform 120ms ease;
      }

      .lane:hover {
        transform: translateY(-1px);
      }

      .lane.changed {
        background: var(--changed);
      }

      .lane.selected {
        outline: 2px solid #2a9d8f;
        background: var(--selected);
      }

      .lane-id {
        font-size: 0.72rem;
        color: #42516d;
      }

      .lane-hex {
        margin-top: 4px;
        font-size: 0.74rem;
      }

      .lane-detail {
        margin-top: 12px;
        border: 1px dashed #bcc4d3;
        border-radius: 12px;
        padding: 10px;
        background: #f7f9fc;
      }

      .lane-detail p {
        margin: 4px 0;
      }

      .note {
        margin-top: 10px;
        color: #40516e;
        line-height: 1.45;
      }

      .pedantic {
        margin-top: 12px;
        border: 1px solid #c7d1e2;
        border-radius: 12px;
        padding: 10px;
        background: #f5f8ff;
      }

      .pedantic p {
        margin: 6px 0;
      }

      .pedantic ul {
        margin: 6px 0;
        padding-left: 18px;
      }

      .pedantic li {
        margin-bottom: 4px;
      }

      .metric-row {
        display: grid;
        grid-template-columns: 1fr;
        gap: 3px;
      }

      .small {
        font-size: 0.82rem;
      }

      @media (max-width: 980px) {
        .layout {
          grid-template-columns: 1fr;
        }
      }
    </style>
  </head>
  <body>
    <div class="shell">
      <section class="hero">
        <h1>Keccak Interactive Teaching Model</h1>
        <p>
          Explore how the Keccak sponge works: absorb message blocks, run
          Keccak-f[1600] rounds, and squeeze output. The state is a 5x5 lane
          matrix (each lane is 64 bits).
        </p>
      </section>

      <main class="layout">
        <section class="panel">
          <h2 class="section-title">Inputs</h2>
          <label for="message">Message</label>
          <textarea id="message">The quick brown fox jumps over the lazy dog</textarea>

          <div class="row">
            <div>
              <label for="variant">Preset</label>
              <select id="variant">
                <option value="sha3-256">SHA3-256 (rate 1088, cap 512)</option>
                <option value="keccak-256">Keccak-256 (rate 1088, cap 512)</option>
                <option value="custom">Custom Parameters</option>
              </select>
            </div>
            <div>
              <label for="suffix">Domain Suffix (hex, custom only)</label>
              <input id="suffix" value="01" />
            </div>
          </div>

          <div id="customFields" hidden>
            <div class="row-4">
              <div>
                <label for="rateBits">Rate</label>
                <input id="rateBits" type="number" min="8" max="1592" step="8" value="1088" />
              </div>
              <div>
                <label for="capacityBits">Capacity</label>
                <input id="capacityBits" type="number" min="8" max="1592" step="8" value="512" />
              </div>
              <div>
                <label for="rounds">Rounds</label>
                <input id="rounds" type="number" min="1" max="24" step="1" value="24" />
              </div>
              <div>
                <label for="outputBytes">Output bytes</label>
                <input id="outputBytes" type="number" min="1" max="256" step="1" value="32" />
              </div>
            </div>
          </div>

          <div class="actions">
            <button id="runBtn" class="primary">Build Trace</button>
            <button id="exampleBtn">Load Example</button>
            <button id="clearBtn" class="warn">Reset Input</button>
          </div>

          <p id="status" class="small"></p>

          <div class="digest">
            <div><strong>Digest:</strong> <span id="digest" class="mono"></span></div>
            <div><strong>Message bytes:</strong> <span id="msgHex" class="mono"></span></div>
            <div><strong>Padded bytes:</strong> <span id="padHex" class="mono"></span></div>
          </div>

          <div class="slider-wrap">
            <div class="actions">
              <button id="prevBtn">Prev Step</button>
              <button id="nextBtn">Next Step</button>
              <button id="playBtn">Play</button>
            </div>
            <input id="stepSlider" type="range" min="0" max="0" value="0" />
            <div class="small">
              Step <span id="stepNow">0</span> / <span id="stepMax">0</span>
            </div>
          </div>
        </section>

        <section class="panel">
          <h2 class="section-title">State Visualizer</h2>
          <div>
            <span id="phaseBadge" class="badge">phase</span>
            <span id="roundBadge" class="badge">round</span>
            <span id="stageBadge" class="badge">stage</span>
          </div>

          <p id="stepTitle" class="step-title">Build a trace to begin.</p>
          <p id="stepSub" class="step-sub small"></p>

          <div class="sponge">
            <div id="boxAbsorb" class="sponge-box">
              <strong>Absorb</strong>
              <div class="small">XOR message blocks into rate lanes</div>
            </div>
            <div id="boxPermute" class="sponge-box">
              <strong>Permute</strong>
              <div class="small">theta -> rho/pi -> chi -> iota</div>
            </div>
            <div id="boxSqueeze" class="sponge-box">
              <strong>Squeeze</strong>
              <div class="small">Read output from rate lanes</div>
            </div>
          </div>

          <div class="grid-wrap">
            <div class="legend">
              <span><span class="dot" style="background:#ffd6a5"></span>changed lane</span>
              <span><span class="dot" style="background:#94d2bd"></span>selected lane</span>
            </div>
            <div id="laneGrid" class="lane-grid"></div>
          </div>

          <div id="laneDetail" class="lane-detail small"></div>
          <p id="stageExplain" class="note small"></p>

          <div class="pedantic small">
            <p><strong>Pedantic walkthrough:</strong> <span id="pedanticMain"></span></p>
            <div class="metric-row">
              <p><strong>Formula:</strong> <span id="pedanticFormula" class="mono"></span></p>
              <p><strong>Changed lanes:</strong> <span id="changedCount"></span></p>
              <p><strong>Changed coordinates:</strong> <span id="changedCoords" class="mono"></span></p>
            </div>
            <ul id="pedanticList"></ul>
          </div>
        </section>
      </main>
    </div>

    <script>
      const LANE_BITS = 64n;
      const LANE_MASK = (1n << LANE_BITS) - 1n;

      const ROUND_CONSTANTS = [
        0x0000000000000001n, 0x0000000000008082n, 0x800000000000808an,
        0x8000000080008000n, 0x000000000000808bn, 0x0000000080000001n,
        0x8000000080008081n, 0x8000000000008009n, 0x000000000000008an,
        0x0000000000000088n, 0x0000000080008009n, 0x000000008000000an,
        0x000000008000808bn, 0x800000000000008bn, 0x8000000000008089n,
        0x8000000000008003n, 0x8000000000008002n, 0x8000000000000080n,
        0x000000000000800an, 0x800000008000000an, 0x8000000080008081n,
        0x8000000000008080n, 0x0000000080000001n, 0x8000000080008008n
      ];

      const ROTATION = [
        [0, 36, 3, 41, 18],
        [1, 44, 10, 45, 2],
        [62, 6, 43, 15, 61],
        [28, 55, 25, 21, 56],
        [27, 20, 39, 8, 14]
      ];

      const STAGE_TEXT = {
        init: "State initialization: all 25 lanes A[x,y] are set to 0 before any input touches the sponge.",
        absorb: "Absorb phase: one message block is XORed into only the rate lanes, then a full permutation is applied.",
        start: "Round start: this is the state entering the current Keccak-f round before theta.",
        theta: "theta: compute column parities C[x], derive D[x], then XOR D[x] into every lane of column x.",
        rhoPi: "rho/pi: rotate each lane by a fixed offset (rho), then move lanes to new coordinates (pi).",
        chi: "chi: row-wise non-linear mixing using NOT and AND with neighboring lanes.",
        iota: "iota: inject round constant RC into lane A[0,0] to remove symmetry across rounds.",
        squeeze: "Squeeze phase: output bytes are read from the rate portion; if more output is needed, permute again."
      };

      const STAGE_FORMULA = {
        init: "A[x,y] <- 0",
        absorb: "A_rate <- A_rate XOR block",
        start: "Round r starts with current A",
        theta: "C[x]=A[x,0]^...^A[x,4]; D[x]=C[x-1]^ROT(C[x+1],1); A[x,y]=A[x,y]^D[x]",
        rhoPi: "B[y,(2x+3y) mod 5]=ROT(A[x,y],r[x,y]); A[x,y]=B[x,y]",
        chi: "A[x,y]=B[x,y] ^ ((~B[x+1,y]) & B[x+2,y])",
        iota: "A[0,0]=A[0,0] ^ RC[r]",
        squeeze: "Z <- first rate bytes of A"
      };

      const ui = {
        message: document.getElementById("message"),
        variant: document.getElementById("variant"),
        suffix: document.getElementById("suffix"),
        customFields: document.getElementById("customFields"),
        rateBits: document.getElementById("rateBits"),
        capacityBits: document.getElementById("capacityBits"),
        rounds: document.getElementById("rounds"),
        outputBytes: document.getElementById("outputBytes"),
        runBtn: document.getElementById("runBtn"),
        exampleBtn: document.getElementById("exampleBtn"),
        clearBtn: document.getElementById("clearBtn"),
        status: document.getElementById("status"),
        digest: document.getElementById("digest"),
        msgHex: document.getElementById("msgHex"),
        padHex: document.getElementById("padHex"),
        prevBtn: document.getElementById("prevBtn"),
        nextBtn: document.getElementById("nextBtn"),
        playBtn: document.getElementById("playBtn"),
        stepSlider: document.getElementById("stepSlider"),
        stepNow: document.getElementById("stepNow"),
        stepMax: document.getElementById("stepMax"),
        phaseBadge: document.getElementById("phaseBadge"),
        roundBadge: document.getElementById("roundBadge"),
        stageBadge: document.getElementById("stageBadge"),
        stepTitle: document.getElementById("stepTitle"),
        stepSub: document.getElementById("stepSub"),
        boxAbsorb: document.getElementById("boxAbsorb"),
        boxPermute: document.getElementById("boxPermute"),
        boxSqueeze: document.getElementById("boxSqueeze"),
        laneGrid: document.getElementById("laneGrid"),
        laneDetail: document.getElementById("laneDetail"),
        stageExplain: document.getElementById("stageExplain"),
        pedanticMain: document.getElementById("pedanticMain"),
        pedanticFormula: document.getElementById("pedanticFormula"),
        changedCount: document.getElementById("changedCount"),
        changedCoords: document.getElementById("changedCoords"),
        pedanticList: document.getElementById("pedanticList")
      };

      const appState = {
        trace: [],
        step: 0,
        selectedX: 0,
        selectedY: 0,
        timer: null
      };

      function createState() {
        return Array.from({ length: 5 }, () => Array.from({ length: 5 }, () => 0n));
      }

      function cloneState(state) {
        return state.map((col) => col.slice());
      }

      function rotl64(value, offset) {
        const off = BigInt(offset % 64);
        if (off === 0n) {
          return value & LANE_MASK;
        }
        return ((value << off) | (value >> (64n - off))) & LANE_MASK;
      }

      function addTrace(trace, state, meta) {
        trace.push({
          ...meta,
          formula: meta.formula || STAGE_FORMULA[meta.stage] || "",
          details: Array.isArray(meta.details) ? meta.details : [],
          state: cloneState(state)
        });
      }

      function theta(state) {
        const c = Array.from({ length: 5 }, () => 0n);
        const d = Array.from({ length: 5 }, () => 0n);
        for (let x = 0; x < 5; x += 1) {
          c[x] = state[x][0] ^ state[x][1] ^ state[x][2] ^ state[x][3] ^ state[x][4];
        }
        for (let x = 0; x < 5; x += 1) {
          d[x] = c[(x + 4) % 5] ^ rotl64(c[(x + 1) % 5], 1);
        }
        for (let x = 0; x < 5; x += 1) {
          for (let y = 0; y < 5; y += 1) {
            state[x][y] = (state[x][y] ^ d[x]) & LANE_MASK;
          }
        }
        return { c, d };
      }

      function rhoPi(state) {
        const b = createState();
        const sampleMoves = [];
        for (let x = 0; x < 5; x += 1) {
          for (let y = 0; y < 5; y += 1) {
            const newX = y;
            const newY = (2 * x + 3 * y) % 5;
            b[newX][newY] = rotl64(state[x][y], ROTATION[x][y]);
            if (sampleMoves.length < 6) {
              sampleMoves.push(
                `A[${x},${y}] -> B[${newX},${newY}] rot ${ROTATION[x][y]}`
              );
            }
          }
        }
        for (let x = 0; x < 5; x += 1) {
          for (let y = 0; y < 5; y += 1) {
            state[x][y] = b[x][y];
          }
        }
        return { sampleMoves };
      }

      function chi(state) {
        const b = cloneState(state);
        const row0Before = Array.from({ length: 5 }, (_, x) => b[x][0]);
        for (let x = 0; x < 5; x += 1) {
          for (let y = 0; y < 5; y += 1) {
            const next = b[(x + 1) % 5][y];
            const next2 = b[(x + 2) % 5][y];
            state[x][y] = (b[x][y] ^ ((~next & LANE_MASK) & next2)) & LANE_MASK;
          }
        }
        const row0After = Array.from({ length: 5 }, (_, x) => state[x][0]);
        return { row0Before, row0After };
      }

      function iota(state, roundIndex) {
        const constant = ROUND_CONSTANTS[roundIndex];
        state[0][0] = (state[0][0] ^ constant) & LANE_MASK;
        return { constant };
      }

      function keccakF1600(state, rounds, trace, contextLabel) {
        const startRound = 24 - rounds;
        for (let round = startRound; round < 24; round += 1) {
          addTrace(trace, state, {
            phase: "permute",
            stage: "start",
            round: round + 1,
            title: `${contextLabel}: round ${round + 1} start`,
            subtitle: "Round enters theta.",
            details: [
              `This round index is ${round + 1} of 24 (Keccak-f[1600] uses 24 fixed rounds).`,
              "No transformation has run yet for this round.",
              "Next operation is theta, which uses column parity."
            ]
          });

          const thetaInfo = theta(state);
          addTrace(trace, state, {
            phase: "permute",
            stage: "theta",
            round: round + 1,
            title: `${contextLabel}: round ${round + 1} after theta`,
            subtitle: "Column parity diffusion.",
            details: [
              `C values: ${thetaInfo.c.map((v) => laneHex(v)).join(" | ")}`,
              `D values: ${thetaInfo.d.map((v) => laneHex(v)).join(" | ")}`,
              "Every lane in column x is XORed with the same D[x]."
            ]
          });

          const rhoPiInfo = rhoPi(state);
          addTrace(trace, state, {
            phase: "permute",
            stage: "rhoPi",
            round: round + 1,
            title: `${contextLabel}: round ${round + 1} after rho/pi`,
            subtitle: "Bit rotations and lane relocation.",
            details: [
              "rho rotates bits within each 64-bit lane by a lane-specific offset.",
              "pi moves each lane to a new coordinate.",
              `Sample moves: ${rhoPiInfo.sampleMoves.join(" ; ")}`
            ]
          });

          const chiInfo = chi(state);
          addTrace(trace, state, {
            phase: "permute",
            stage: "chi",
            round: round + 1,
            title: `${contextLabel}: round ${round + 1} after chi`,
            subtitle: "Non-linear row mixing.",
            details: [
              "chi processes one row at a time and is the non-linear step.",
              `Row y=0 before: ${chiInfo.row0Before.map((v) => laneHex(v)).join(" | ")}`,
              `Row y=0 after: ${chiInfo.row0After.map((v) => laneHex(v)).join(" | ")}`
            ]
          });

          const iotaInfo = iota(state, round);
          addTrace(trace, state, {
            phase: "permute",
            stage: "iota",
            round: round + 1,
            title: `${contextLabel}: round ${round + 1} after iota`,
            subtitle: "Round constant injected into lane A[0,0].",
            details: [
              `Round constant RC[${round + 1}] = ${laneHex(iotaInfo.constant)}`,
              "Only lane A[0,0] is directly XORed in this step.",
              "The constant prevents symmetric round behavior."
            ]
          });
        }
      }

      function bytesToHex(bytes) {
        return bytes.map((v) => v.toString(16).padStart(2, "0")).join("");
      }

      function previewHex(bytes, maxChars = 96) {
        const hex = bytesToHex(bytes);
        if (hex.length <= maxChars) {
          return hex || "(empty)";
        }
        return `${hex.slice(0, maxChars)}...`;
      }

      function parseHexByte(value) {
        const text = value.trim().replace(/^0x/i, "");
        if (text.length === 0 || text.length > 2 || !/^[0-9a-fA-F]+$/.test(text)) {
          return null;
        }
        const parsed = Number.parseInt(text, 16);
        if (!Number.isInteger(parsed) || parsed < 0 || parsed > 255) {
          return null;
        }
        return parsed;
      }

      function keccakPad(messageBytes, rateBytes, suffixByte) {
        const out = [...messageBytes];
        const q = rateBytes - (out.length % rateBytes);
        if (q === 1) {
          out.push((suffixByte ^ 0x80) & 0xff);
          return out;
        }
        out.push(suffixByte);
        for (let i = 0; i < q - 2; i += 1) {
          out.push(0x00);
        }
        out.push(0x80);
        return out;
      }

      function xorBlockIntoState(state, block, rateBytes) {
        for (let i = 0; i < rateBytes; i += 1) {
          const byte = block[i] ?? 0;
          const laneIndex = Math.floor(i / 8);
          const x = laneIndex % 5;
          const y = Math.floor(laneIndex / 5);
          const shift = BigInt((i % 8) * 8);
          state[x][y] = (state[x][y] ^ (BigInt(byte) << shift)) & LANE_MASK;
        }
      }

      function readRateBytes(state, rateBytes) {
        const out = [];
        for (let i = 0; i < rateBytes; i += 1) {
          const laneIndex = Math.floor(i / 8);
          const x = laneIndex % 5;
          const y = Math.floor(laneIndex / 5);
          const shift = BigInt((i % 8) * 8);
          const value = Number((state[x][y] >> shift) & 0xffn);
          out.push(value);
        }
        return out;
      }

      function runModel(message, cfg) {
        const encoder = new TextEncoder();
        const messageBytes = Array.from(encoder.encode(message));
        const padded = keccakPad(messageBytes, cfg.rateBytes, cfg.suffix);
        const state = createState();
        const trace = [];

        addTrace(trace, state, {
          phase: "init",
          stage: "init",
          round: null,
          title: "Initial state",
          subtitle: "All 25 lanes are zero.",
          details: [
            "Keccak-f[1600] state is a 5x5 matrix of 64-bit lanes.",
            `Rate = ${cfg.rateBits} bits, capacity = ${cfg.capacityBits} bits.`,
            "No message material has been absorbed yet."
          ]
        });

        const blockCount = Math.ceil(padded.length / cfg.rateBytes);
        for (let blockIndex = 0; blockIndex < blockCount; blockIndex += 1) {
          const start = blockIndex * cfg.rateBytes;
          const block = padded.slice(start, start + cfg.rateBytes);
          xorBlockIntoState(state, block, cfg.rateBytes);
          addTrace(trace, state, {
            phase: "absorb",
            stage: "absorb",
            round: null,
            title: `Absorb block ${blockIndex + 1}/${blockCount}`,
            subtitle: "Block bytes are XORed into the rate portion.",
            details: [
              `Block preview (hex): ${previewHex(block)}`,
              `Exactly ${cfg.rateBytes} byte(s) map into rate lanes.`,
              `Capacity (${cfg.capacityBits} bits) is not directly modified in absorb.`
            ]
          });

          keccakF1600(state, cfg.rounds, trace, `Block ${blockIndex + 1}`);
        }

        const output = [];
        let squeezeChunk = 0;
        while (output.length < cfg.outputBytes) {
          const chunkBytes = readRateBytes(state, cfg.rateBytes);
          const toTake = Math.min(cfg.outputBytes - output.length, chunkBytes.length);
          output.push(...chunkBytes.slice(0, toTake));
          squeezeChunk += 1;
          addTrace(trace, state, {
            phase: "squeeze",
            stage: "squeeze",
            round: null,
            title: `Squeeze chunk ${squeezeChunk}`,
            subtitle: `Read ${toTake} byte(s) from rate lanes.`,
            details: [
              `Read window size: ${cfg.rateBytes} bytes from rate section.`,
              `Bytes emitted this chunk: ${toTake}.`,
              output.length < cfg.outputBytes
                ? "Digest not complete yet, another permutation is required."
                : "Digest complete for requested output size."
            ]
          });

          if (output.length < cfg.outputBytes) {
            keccakF1600(state, cfg.rounds, trace, `Squeeze ${squeezeChunk}`);
          }
        }

        return {
          trace,
          digestHex: bytesToHex(output),
          messageHex: bytesToHex(messageBytes),
          paddedHex: bytesToHex(padded)
        };
      }

      function laneHex(value) {
        return value.toString(16).padStart(16, "0");
      }

      function laneBits(value) {
        return value.toString(2).padStart(64, "0").replace(/(.{8})(?=.)/g, "$1 ");
      }

      function getConfig() {
        const variant = ui.variant.value;
        if (variant === "sha3-256") {
          return {
            rateBits: 1088,
            capacityBits: 512,
            rounds: 24,
            outputBytes: 32,
            suffix: 0x06,
            rateBytes: 136
          };
        }
        if (variant === "keccak-256") {
          return {
            rateBits: 1088,
            capacityBits: 512,
            rounds: 24,
            outputBytes: 32,
            suffix: 0x01,
            rateBytes: 136
          };
        }

        const rateBits = Number.parseInt(ui.rateBits.value, 10);
        const capacityBits = Number.parseInt(ui.capacityBits.value, 10);
        const rounds = Number.parseInt(ui.rounds.value, 10);
        const outputBytes = Number.parseInt(ui.outputBytes.value, 10);
        const suffix = parseHexByte(ui.suffix.value);

        if (!Number.isInteger(rateBits) || !Number.isInteger(capacityBits) || !Number.isInteger(rounds) || !Number.isInteger(outputBytes)) {
          throw new Error("Custom values must be integers.");
        }
        if (rateBits <= 0 || capacityBits <= 0 || rateBits + capacityBits !== 1600 || rateBits % 8 !== 0) {
          throw new Error("Custom parameters must satisfy rate + capacity = 1600 and rate % 8 = 0.");
        }
        if (rounds < 1 || rounds > 24) {
          throw new Error("Rounds must be between 1 and 24.");
        }
        if (outputBytes < 1 || outputBytes > 256) {
          throw new Error("Output bytes must be between 1 and 256.");
        }
        if (suffix === null) {
          throw new Error("Domain suffix must be a hex byte (00 to ff).");
        }

        return {
          rateBits,
          capacityBits,
          rounds,
          outputBytes,
          suffix,
          rateBytes: rateBits / 8
        };
      }

      function phaseRank(phase) {
        if (phase === "init") return 0;
        if (phase === "absorb") return 1;
        if (phase === "permute") return 2;
        if (phase === "squeeze") return 3;
        return 0;
      }

      function diffSummary(prevState, currentState) {
        if (!prevState) {
          return { count: 0, coords: [] };
        }
        const coords = [];
        for (let y = 0; y < 5; y += 1) {
          for (let x = 0; x < 5; x += 1) {
            if (prevState[x][y] !== currentState[x][y]) {
              coords.push(`A[${x},${y}]`);
            }
          }
        }
        return { count: coords.length, coords };
      }

      function renderSponge(phase) {
        const boxes = [
          { el: ui.boxAbsorb, phase: "absorb" },
          { el: ui.boxPermute, phase: "permute" },
          { el: ui.boxSqueeze, phase: "squeeze" }
        ];
        const currentRank = phaseRank(phase);
        for (const box of boxes) {
          box.el.classList.remove("active", "current");
          const rank = phaseRank(box.phase);
          if (rank <= currentRank && currentRank > 0) {
            box.el.classList.add("active");
          }
          if (box.phase === phase) {
            box.el.classList.add("current");
          }
        }
      }

      function renderGrid() {
        const current = appState.trace[appState.step];
        const prev = appState.step > 0 ? appState.trace[appState.step - 1] : null;
        ui.laneGrid.innerHTML = "";

        for (let y = 0; y < 5; y += 1) {
          for (let x = 0; x < 5; x += 1) {
            const lane = document.createElement("button");
            lane.type = "button";
            lane.className = "lane";

            if (prev && prev.state[x][y] !== current.state[x][y]) {
              lane.classList.add("changed");
            }
            if (x === appState.selectedX && y === appState.selectedY) {
              lane.classList.add("selected");
            }

            lane.dataset.x = String(x);
            lane.dataset.y = String(y);
            lane.innerHTML = `
              <div class="lane-id">A[${x},${y}]</div>
              <div class="lane-hex mono">${laneHex(current.state[x][y])}</div>
            `;
            ui.laneGrid.appendChild(lane);
          }
        }
      }

      function renderLaneDetail() {
        const current = appState.trace[appState.step];
        const prev = appState.step > 0 ? appState.trace[appState.step - 1] : null;
        const value = current.state[appState.selectedX][appState.selectedY];
        const changed = prev
          ? prev.state[appState.selectedX][appState.selectedY] !== value
          : false;
        ui.laneDetail.innerHTML = `
          <p><strong>Selected lane:</strong> A[${appState.selectedX},${appState.selectedY}]</p>
          <p><strong>Changed this step:</strong> ${changed ? "yes" : "no"}</p>
          <p><strong>Hex:</strong> <span class="mono">${laneHex(value)}</span></p>
          <p><strong>Binary:</strong> <span class="mono">${laneBits(value)}</span></p>
          <p><strong>Decimal:</strong> <span class="mono">${value.toString(10)}</span></p>
        `;
      }

      function renderStepMeta() {
        const item = appState.trace[appState.step];
        const prev = appState.step > 0 ? appState.trace[appState.step - 1] : null;
        const delta = diffSummary(prev ? prev.state : null, item.state);
        const shownCoords = delta.coords.slice(0, 10);
        const hiddenCount = Math.max(0, delta.coords.length - shownCoords.length);

        ui.stepNow.textContent = String(appState.step);
        ui.stepMax.textContent = String(appState.trace.length - 1);
        ui.stepTitle.textContent = item.title;
        ui.stepSub.textContent = item.subtitle || "";
        ui.phaseBadge.textContent = `phase: ${item.phase}`;
        ui.stageBadge.textContent = `stage: ${item.stage}`;
        ui.roundBadge.textContent = item.round ? `round: ${item.round}` : "round: -";
        ui.stageExplain.textContent = STAGE_TEXT[item.stage] || "";
        ui.pedanticMain.textContent = STAGE_TEXT[item.stage] || "";
        ui.pedanticFormula.textContent = item.formula || STAGE_FORMULA[item.stage] || "-";
        ui.changedCount.textContent = `${delta.count} / 25 lanes`;
        ui.changedCoords.textContent = delta.coords.length
          ? hiddenCount > 0
            ? `${shownCoords.join(", ")}, +${hiddenCount} more`
            : shownCoords.join(", ")
          : "none";
        ui.pedanticList.innerHTML = "";
        for (const detail of item.details) {
          const li = document.createElement("li");
          li.textContent = detail;
          ui.pedanticList.appendChild(li);
        }
        if (!item.details.length) {
          const li = document.createElement("li");
          li.textContent = "No additional details for this step.";
          ui.pedanticList.appendChild(li);
        }
        renderSponge(item.phase);
      }

      function render() {
        if (appState.trace.length === 0) {
          ui.stepTitle.textContent = "Build a trace to begin.";
          ui.stepSub.textContent = "";
          ui.laneGrid.innerHTML = "";
          ui.laneDetail.textContent = "";
          ui.stageExplain.textContent = "";
          ui.pedanticMain.textContent = "";
          ui.pedanticFormula.textContent = "";
          ui.changedCount.textContent = "0 / 25 lanes";
          ui.changedCoords.textContent = "none";
          ui.pedanticList.innerHTML = "";
          return;
        }
        ui.stepSlider.max = String(appState.trace.length - 1);
        ui.stepSlider.value = String(appState.step);
        renderStepMeta();
        renderGrid();
        renderLaneDetail();
      }

      function stopPlayback() {
        if (appState.timer) {
          clearInterval(appState.timer);
          appState.timer = null;
        }
        ui.playBtn.textContent = "Play";
      }

      function nextStep() {
        if (appState.trace.length === 0) return;
        if (appState.step < appState.trace.length - 1) {
          appState.step += 1;
          render();
          return;
        }
        stopPlayback();
      }

      function buildTrace() {
        stopPlayback();
        ui.status.textContent = "";
        try {
          const cfg = getConfig();
          const result = runModel(ui.message.value, cfg);
          appState.trace = result.trace;
          appState.step = 0;
          appState.selectedX = 0;
          appState.selectedY = 0;
          ui.digest.textContent = result.digestHex;
          ui.msgHex.textContent = result.messageHex || "(empty)";
          ui.padHex.textContent = result.paddedHex;
          render();
        } catch (err) {
          ui.status.textContent = err instanceof Error ? err.message : "Unknown error";
        }
      }

      ui.variant.addEventListener("change", () => {
        ui.customFields.hidden = ui.variant.value !== "custom";
      });

      ui.runBtn.addEventListener("click", buildTrace);
      ui.exampleBtn.addEventListener("click", () => {
        ui.message.value = "Keccak helps us see diffusion and confusion in sponge hashing.";
      });
      ui.clearBtn.addEventListener("click", () => {
        ui.message.value = "";
      });

      ui.prevBtn.addEventListener("click", () => {
        stopPlayback();
        if (appState.step > 0) {
          appState.step -= 1;
          render();
        }
      });

      ui.nextBtn.addEventListener("click", () => {
        stopPlayback();
        nextStep();
      });

      ui.playBtn.addEventListener("click", () => {
        if (appState.trace.length === 0) return;
        if (appState.timer) {
          stopPlayback();
          return;
        }
        ui.playBtn.textContent = "Pause";
        appState.timer = setInterval(nextStep, 1500);
      });

      ui.stepSlider.addEventListener("input", (event) => {
        stopPlayback();
        appState.step = Number.parseInt(event.target.value, 10);
        render();
      });

      ui.laneGrid.addEventListener("click", (event) => {
        const target = event.target.closest(".lane");
        if (!target) return;
        appState.selectedX = Number.parseInt(target.dataset.x, 10);
        appState.selectedY = Number.parseInt(target.dataset.y, 10);
        render();
      });

      window.addEventListener("keydown", (event) => {
        if (event.key === "ArrowRight") {
          nextStep();
        } else if (event.key === "ArrowLeft") {
          if (appState.step > 0) {
            appState.step -= 1;
            render();
          }
        }
      });

      buildTrace();
    </script>
  </body>
</html>
